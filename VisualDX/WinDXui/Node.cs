using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Windows.Forms;
using System.Diagnostics;
using System.Text.RegularExpressions;

namespace WinDX.UI
{
    public class Node : IGroupedObject
    {
        public enum NodeParameterStatusChange {
            ParameterValueChanged = 0x100000,
            PatemeterSetValueChanged = 0x000001 | 0x100000,
            ParameterSetValueToDefaulting = 0x000002 | 0x100000,
            ParameterVisibilityChanged = 0x200000,
            ParameterBecomesVisible = 0x000003 | 0x200000,
            ParameterBecomesInvisible = 0x000004 | 0x200000,
            ParameterArkChanged = 0x400000,
            ParameterArkRemoved = 0x000008 | 0x400000,
            ParameterArkAdded = 0x000010 | 0x400000
        };

        public enum NodeStatusChange
        {
            NodeSelected,
            NodeDeselected
        };

        #region Private Instance Variables
        private const String indent = "    ";

        /// <summary>
        /// Used only be the Network for sorting, graph analysis, etc.
        /// See isMarked(), setMarked() and clearMarked().
        /// </summary>
        private bool marked;

        /// <summary>
        /// Should the executive cache the module's state.
        /// </summary>
        private Cacheability nodeCacheability;

        /// <summary>
        /// The symbol for the node label (contained in theSymbolTable)
        /// </summary>
        private Symbol labelSymbol;

        /// <summary>
        /// The instance number, allocated from the definition.
        /// </summary>
        private int instanceNumber;

        /// <summary>
        /// The network this node belongs to
        /// </summary>
        private Network network;

        /// <summary>
        /// Pointer into a table of definitions generated by the MDF file
        /// </summary>
        private NodeDefinition definition;

        /// <summary>
        /// Current values and definitions for inputs and outputs
        /// </summary>
        private List<Parameter> inputParameters = new List<Parameter>();
        private List<Parameter> outputParameters = new List<Parameter>();

        /// <summary>
        /// Pointer to the UI standin for this node.
        /// </summary>
        private StandIn standin;

        /// <summary>
        /// Pointer to the cdb for this node.
        /// </summary>
        private ConfigurationDialog cdb;

        /// <summary>
        /// Upper left-hand corner of standin for this module.
        /// </summary>
        private int vpe_xpos, vpe_ypos;

        /// <summary>
        /// On behalf of automatic graph layout we need to store information
        /// on a per-node basis.  No one outside of the layout class will
        /// ever access this information, but it's natural to keep in
        /// associated with the Node for fast lookup.
        /// </summary>
        private Object layout_information;

        #endregion

        #region Private Methods
        /// <summary>
        /// his dispatches messages to this->execModuleMessageHandler().
        /// Messages are not noticed unless this handler is installed
        /// (in this->updateModuleMessageProtocol() via this->netPrintNode()).
        /// </summary>
        /// <param name="clientData"></param>
        /// <param name="id"></param>
        /// <param name="line"></param>
        private static void ExecModuleMessageHandler(Object clientData, int id, String line)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Let the Configuration dialog box know that the parameter has changed.
        /// Assumes that the node currently has a cdb.
        /// </summary>
        /// <param name="p"></param>
        /// <param name="index"></param>
        private void notifyCDBParameterChanged(Parameter p, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set the index'th parameter value of the parameter list given by io
        /// to the given value  of type t.  if t==DXType::UndefinedType, then
        /// be sure it can be assigned to one of the allowed types in the
        /// ParameterDefinition.  If 'value' is null, then clear the value (and 
        /// handle as a successful setting) and return the default type for the 
        /// given parameter.
        /// We you the Parameter methods to try and help certain values become
        /// the given type (i.e. by adding "'s, {}'s, []'s and so on).
        /// If send is true (the default), the results will be sent to the server
        /// if possible.
        /// If notify is TRUE, then call ioParameterStatusChanged() with one of
        /// Node::ParameterSetValueChanged and Node::ParameterValueChanged.
        /// index is 0 based.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <param name="t"></param>
        /// <param name="send"></param>
        /// <param name="notify"></param>
        /// <returns></returns>
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value)
        {
            return setIOValue(ref io, index, value, DXTypeVals.UndefinedType, true, true);
        }
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value, DXTypeVals t)
        {
            return setIOValue(ref io, index, value, t, true, true);
        }
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value, DXTypeVals t, bool send)
        {
            return setIOValue(ref io, index, value, t, send, true);
        }
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value, DXTypeVals t, bool send, bool notify)
        {
            Debug.Assert(index >= 1);

            Parameter p = io[index-1];
            Debug.Assert(p != null);

            bool was_set = !p.IsDefaulting;

            DXTypeVals type = DXTypeVals.UndefinedType;
            if (t == DXTypeVals.UndefinedType)
                type = p.setValue(value);
            else if (p.setValue(value, t))
                type = t;

            // If a NULL value is found (i.e. clearing the value), then return the
            // type as the default type for the parameter as "NULL" should match any
            // type.
            if (value == null)
                type = p.getDefaultType();
            if (type != DXTypeVals.UndefinedType)
            {
                // And now send the value to the executive if there is a connection.
                // Note that we don't need to set the network dirty, because we can
                // send the changes ourselves.
                if (send)
                {
                    DXPacketIF pif = DXApplication.theDXApplication.getPacketIF();
                    if (pif != null)
                        sendValues(false);
                }

                // Let those who need to know that the value has changed.
                if (notify)
                {
                    notifyIoParameterStatusChanged(io == inputParameters, index,
                        was_set ? NodeParameterStatusChange.PatemeterSetValueChanged :
                        NodeParameterStatusChange.ParameterValueChanged);
                }
            }
            return type;
        }

        /// <summary>
        /// This is the same as setIOValue, but it sends the value to the
        /// executive without causing an executive execution in execute on change.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <param name="t"></param>
        /// <returns></returns>
        private DXTypeVals setIOValueQuietly(ref List<Parameter> io, int index,
            String value)
        {
            return setIOValueQuietly(ref io, index, value, DXTypeVals.UndefinedType);
        }
        private DXTypeVals setIOValueQuietly(ref List<Parameter> io, int index,
            String value, DXTypeVals t)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Mark the given parameter as clean.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="dirty"></param>
        private void setIODirty(ref List<Parameter> io, int index, bool dirty)
        {
            Debug.Assert(index >= 1);
            Parameter p = io[index - 1];
            Debug.Assert(p != null);

            if (dirty)
                p.setDirty();
            else
                p.clearDirty();

            if (io == inputParameters && network.IsMacro)
                network.setDirty();
        }

        /// <summary>
        /// Determine if the index'th parameter in the give list is connected 
        /// (i.e. has an arc) to another parameter. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOConnected(List<Parameter> io, int index)
        {
            Debug.Assert(index >= 1);
            Parameter p = io[index - 1];
            Debug.Assert(p != null);

            return p.IsConnected;
        }

        /// <summary>
        /// Get the default value of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIODefaultValueString(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set/Get the cacheability of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private Cacheability getIOCacheability(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }
        private bool isIOCacheabilityWriteable(List<Parameter> io, int index)
        {
            Parameter p;
            Debug.Assert(index >= 1);
            p = io[index - 1];
            Debug.Assert(p != null);
            return p.HasWriteableCacheability;
        }

        /// <summary>
        /// Get the currently set value of the index'th parameter in the given 
        /// list.  Ignores the defaulting stuff.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIOSetValueString(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the default value of the index'th parameter in the given list.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIODefaulting(List<Parameter> io, int index)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);
            return p.IsDefaulting;
        }

        /// <summary>
        /// Determine if the value of the index'th parameter in the given list
        /// has been set, independent of whether it's defaulting or not.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOSet(List<Parameter> io, int index)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);

            return p.HasValue;
        }

        /// <summary>
        /// Get the value of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIOValueString(List<Parameter> io, int index)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);

            return p.getValueString();
        }

        /// <summary>
        /// Get the type of the set value of the index'th parameter in the list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private DXTypeVals getIOSetValueType(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the name of the input as specified in the network
        /// (i.e. main_Display_1_in_3)
        /// </summary>
        /// <param name="index"></param>
        /// <param name="input"></param>
        /// <param name="buffer"></param>
        /// <returns></returns>
        private String getNetworkIONameString(int index,
            bool input)
        {
            String prefix = network.getPrefix();

            return String.Format("{0}{1}_{2}_{3}_{4}", prefix,
                NameString, instanceNumber, (input ? "in" : "out"),
                index);
        }

        /// <summary>
        /// Get the name of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIONameString(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the description of the index'th parameter in the given list.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIODescription(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return a readonly list of strings that represent the types for 
        /// the given parameter.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String[] getIOTypeStrings(List<Parameter> io, int index)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);

            return p.getTypeStrings();
        }

        /// <summary>
        /// Return a list of types for the given parameter.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns>A list of types for the given parameter.</returns>
        List<DXType> getIOTypes(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the index'th parameter from the given list has visible tab. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOVisible(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set the index'th parameter from the given list to be visible.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="v"></param>
        private void setIOVisibility(List<Parameter> io, int index, bool v)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);

            if (p.IsVisible == v)
                return;

            p.setVisibility(v);

            notifyIoParameterStatusChanged(io == this.inputParameters, index,
                (v ? NodeParameterStatusChange.ParameterBecomesVisible :
                NodeParameterStatusChange.ParameterBecomesInvisible));
        }

        /// <summary>
        /// Set all unconnected, defaulting params to be either visible or not.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="v"></param>
        private void setAllIOVisibility(List<Parameter> io, bool v)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the index'th parameter from the given list is viewable
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOViewable(List<Parameter> io, int index)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);
            return p.IsViewable;
        }

        /// <summary>
        /// Print 'name = value'  for the index'th parameter in the given list.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        private String ioValueString(List<Parameter> io, int index, String prefix)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the index'th parameter in the given list is required. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIORequired(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the given parameter list contains parameters which
        /// can be exposed, implying that there are some that are hidden. 
        /// </summary>
        /// <param name="io"></param>
        /// <returns></returns>
        private bool hasExposableIO(List<Parameter> io)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the given parameter list contains parameters which
        /// can be hidden, implying that there are some that are exposed. 
        /// </summary>
        /// <param name="io"></param>
        /// <returns></returns>
        private bool hasHideableIO(List<Parameter> io)
        {
            throw new Exception("Not Yet Implemented");
        }



        /// <summary>
        /// Return a list of Arks for the given parameter.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public List<Ark> getIOArks(List<Parameter> io, int index)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index-1];
            Debug.Assert(p != null);

            return p.Arks;
        }
        #endregion

        #region Protected Instance Variables

        /// <summary>
        /// Used as a unique identifier for this instance of this Node when  
        /// installing the Module message handler.
        /// </summary>
        protected String moduleMessageId;

        #endregion

        #region Protected Methods

        protected void setInstanceNumber(int inst) { instanceNumber = inst; }
        protected bool appendInput(Parameter p)
        {
            if (inputParameters == null)
                return false;
            inputParameters.Add(p);
            return true;
        }
        protected bool appendOutput(Parameter p)
        {
            if (outputParameters == null)
                return false;
            outputParameters.Add(p);
            return true;
        }

        /// <summary>
        /// Add an Ark to the index'th parameter of parameter list 'io'.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="a"></param>
        /// <returns></returns>
        protected virtual bool addIOArk(List<Parameter> io, int index, Ark a)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);
            if (!p.addArk(a))
                return false;

            notifyIoParameterStatusChanged(io == inputParameters, index,
                NodeParameterStatusChange.ParameterArkAdded);

            return true;
        }
        protected virtual bool removeIOArk(List<Parameter> io, int index, Ark a)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected bool removeInputArk(int index, Ark a)
        {
            return removeIOArk(inputParameters, index, a);
        }
        protected bool removeOutputArk(int index, Ark a)
        {
            return removeIOArk(outputParameters, index, a);
        }

        /// <summary>
        /// Add/remove a set of repeatable input or output parameters to the
        /// this node.   An error  ocurrs if the parameter list indicated does
        /// not have repeatable parameters.
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        protected virtual bool addRepeats(bool input)
        {
            NodeDefinition nd = Definition;
            ParameterDefinition pd;
            List<Parameter> plist; 
            int iocnt = 0;
            int repeats = 0;

            if (input)
            {
                repeats = nd.InputRepeatCount;
                plist = inputParameters;
                iocnt = InputCount;
            }
            else
            {
                repeats = nd.OutputRepeatCount;
                plist = outputParameters;
                iocnt = OutputCount;
            }

            Debug.Assert(repeats > 0);

            network.setDirty();

            for (int i = 1; i <= repeats; i++)
            {
                if (input)
                    pd = nd.getInputDefinition(iocnt + i);
                else
                    pd = nd.getOutputDefinition(iocnt + i);

                Parameter p = nd.newParameter(pd, this, iocnt + i);
                plist.Add(p);
                if (cdb != null)
                {
                    if (input)
                        cdb.newInput(iocnt + i);
                    else
                        cdb.newOutput(iocnt + i);
                }
                if (standin != null)
                {
                    if (input)
                        standin.addInput(iocnt + i);
                    else
                        standin.addOutput(iocnt + i);
                }
            }
            return true;
        }
        protected virtual bool removeRepeats(bool input)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected Parameter getInputParameter(int i)
        {
            return inputParameters[i-1];
        }
        protected Parameter getOutputParameter(int i)
        {
            return outputParameters[i-1];
        }

        protected virtual String strcatParameterNameLvalue(Parameter p,
            String prefix, int index)
        {
            String ioname;
            if (p.IsInput)
                ioname = "in";
            else
                ioname = "out";

            return String.Format("{0}{1}_{2}_{3}_{4}",
                prefix, NameString, InstanceNumber, ioname, index);
        }
        protected String strcatParameterValueString(Parameter p, int index)
        {
            return p.getValueString();
        }

        /// <summary>
        /// Parse either on input or an output comment, setting the value of
        /// the indicated parameter with the value and type found in the comment.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="comment"></param>
        /// <param name="filename"></param>
        /// <param name="lineno"></param>
        /// <returns></returns>
        protected virtual bool parseIOComment(bool input, String comment,
            String filename, int lineno)
        {
            return parseIOComment(input, comment, filename, lineno, false);
        }
        protected virtual bool parseIOComment(bool input, String comment, 
            String filename, int lineno, bool valueOnly)
        {
            Regex regex;
            Match m;

            int defaulting = 0, allowed_params, ionum = 0;
            bool visible = true;
            DXTypeVals type = DXTypeVals.UndefinedType, r = DXTypeVals.UndefinedType;
            String ioname;
            bool parse_error = false;

            Debug.Assert(comment != null);

            if (input)
            {
                if (!comment.StartsWith(" input["))
                    return false;

                if (valueOnly)
                {
                    regex = new Regex(@" input\[(\d+)\]: defaulting = (\d+)");
                    m = regex.Match(comment);
                    if (!m.Success)
                        parse_error = true;
                    else
                    {
                        ionum = Int32.Parse(m.Groups[1].ToString());
                        defaulting = Int32.Parse(m.Groups[2].ToString());
                    }
                    type = DXTypeVals.UndefinedType;
                }
                else
                {
                    regex = new Regex(@" input\[(\d+)\]: defaulting = (\d+), visible = (\d+), type = (\d+)");
                    m = regex.Match(comment);
                    if (!m.Success)
                    {
                        regex = new Regex(@" input\[(\d+)\]: visible = (\d+)");
                        m = regex.Match(comment);
                        if (!m.Success)
                        {
                            regex = new Regex(@" input\[(\d+)\]: type = (\d+)");
                            m = regex.Match(comment);
                            if (!m.Success)
                            {
                                regex = new Regex(@" input\[(\d+)\]: defaulting (\d+), type = (\d+)");
                                m = regex.Match(comment);
                                if (!m.Success)
                                    parse_error = true;
                                else
                                {
                                    ionum = Int32.Parse(m.Groups[1].ToString());
                                    defaulting = Int32.Parse(m.Groups[2].ToString());
                                    type = (DXTypeVals)long.Parse(m.Groups[3].ToString());
                                }
                            }
                            else
                            {
                                ionum = Int32.Parse(m.Groups[1].ToString());
                                type = (DXTypeVals)long.Parse(m.Groups[2].ToString());
                            }
                        }
                        else
                        {
                            ionum = Int32.Parse(m.Groups[1].ToString());
                            visible = Int32.Parse(m.Groups[2].ToString()) > 0;
                            defaulting = 1;
                        }
                    }
                    else
                    {
                        ionum = Int32.Parse(m.Groups[1].ToString());
                        defaulting = Int32.Parse(m.Groups[2].ToString());
                        visible = Int32.Parse(m.Groups[3].ToString()) > 0;
                        type = (DXTypeVals)long.Parse(m.Groups[4].ToString());
                    }
                }
                ioname = "input";
                allowed_params = InputCount;
            }
            else // An output
            {
                if (!comment.StartsWith(" output["))
                    return false;

                if (valueOnly)
                {
                    regex = new Regex(@" output\[(\d+)\]: defaulting = (\d+)");
                    m = regex.Match(comment);
                    if (!m.Success)
                        parse_error = true;
                    type = DXTypeVals.UndefinedType;
                }
                else
                {
                    regex = new Regex(@" output\[(\d+)\]: visible = (\d+), type = (\d+)");
                    m = regex.Match(comment);
                    if (!m.Success)
                    {
                        regex = new Regex(@" output\[(\d+)\]: type = (\d+)");
                        m = regex.Match(comment);
                        if (!m.Success)
                        {
                            regex = new Regex(@" output\[(\d+)\]: visible = (\d+)");
                            m = regex.Match(comment);
                            if (!m.Success)
                                parse_error = true;
                            else
                            {
                                ionum = Int32.Parse(m.Groups[1].ToString());
                                visible = Int32.Parse(m.Groups[2].ToString())>0;
                            }
                        }
                        else
                        {
                            ionum = Int32.Parse(m.Groups[1].ToString());
                            type = (DXTypeVals)long.Parse(m.Groups[2].ToString());
                        }
                    }
                    else
                    {
                        ionum = Int32.Parse(m.Groups[1].ToString());
                        visible = Int32.Parse(m.Groups[2].ToString())>0;
                        type = (DXTypeVals)long.Parse(m.Groups[3].ToString());
                    }
                }
                ioname = "output";
                allowed_params = OutputCount;
            }
            if (parse_error)
            {
                ErrorDialog ed = new ErrorDialog();
                ed.post("Can't parse {0} comment file {1} line {2}", ioname,
                    filename, lineno);
                return true;
            }

            // If the input paramter is out of bounds, then something is wrong...
            if (ionum > allowed_params)
            {
                ErrorDialog ed = new ErrorDialog();
                ed.post("Bad {0} number ({1}) file {2} line {3}", input? "input":"output", ionum,
                    filename, lineno);
                return true;
            }

            // If parsed ok and node exists, convert value.
            if (comment.Contains("value ="))
            {
                String value = comment.Substring(comment.IndexOf("value =") + 8).Trim();
                
                if (value != null && value != "")
                {
                    if (getNetwork().getNetMajorVersion() <= 1)
                        type = DXType.ConvertVersionType(type);

                    if (input)
                    {
                        if (value.StartsWith("(") && value.EndsWith(")"))
                        {
                            // Skip descriptive settings
                            defaulting = 1;
                            r = DXTypeVals.ObjectType;
                        }
                        else if (defaulting > 0)
                        {
                            r = setInputValue(ionum, value, type, false);
                            if (r == DXTypeVals.UndefinedType &&
                                type != DXTypeVals.UndefinedType)
                                r = setInputValue(ionum, value, DXTypeVals.UndefinedType, false);
                        }
                        else
                        {
                            r = setInputValue(ionum, value, type, false);
                            if (r == DXTypeVals.UndefinedType &&
                                type != DXTypeVals.UndefinedType)
                                r = setInputValue(ionum, value, DXTypeVals.UndefinedType, false);
                        }
                    }
                    else
                    {
                        r = setOutputValue(ionum, value, type, false);
                        if (r == DXTypeVals.UndefinedType &&
                            type != DXTypeVals.UndefinedType)
                            r = setOutputValue(ionum, value, DXTypeVals.UndefinedType, false);
                    }
                }

                if (r == DXTypeVals.UndefinedType)
                {
                    ErrorDialog ed = new ErrorDialog();
                    ed.post("Encountered an erroneous input value (file {0}, line {1})",
                        filename, lineno);
                    return true;
                }
            }

            if (!valueOnly)
            {
                if (input)
                {
                    setInputVisibility(ionum, visible);
                }
                else
                {
                    useAssignedOutputValue(ionum, false);
                    setOutputVisibility(ionum, visible);
                }
            }

            return true;
        }

        /// <summary>
        /// These are called when a 'node' comment is found in the .net.
        /// </summary>
        /// <param name="comment"></param>
        /// <param name="filename"></param>
        /// <param name="lineno"></param>
        /// <returns></returns>
        protected bool netParseNodeComment(String comment, String filename,
            int lineno)
        {
            String node_name, labelstr;
            int instance, x, y, n_inputs, n_outputs;

            if (!comment.StartsWith(" node "))
                return false;

            Regex regex = new Regex(@" node (.*)\[(\d+)\]: x = (\d+), y = (\d+), inputs = (\d+), outputs = (\d+), label = (.*)");
            Match m = regex.Match(comment);
            if (!m.Success)
            {
                regex = new Regex(@" node (.*)\[(\d+)\]: x = (\d+), y = (\d+), inputs = (\d+), label = (.*)");
                m = regex.Match(comment);
                if (!m.Success)
                {
                    regex = new Regex(@" node (.*)\[(\d+)\]: x = (\d+), y = (\d+), label = (.*)");
                    m = regex.Match(comment);
                    if (!m.Success)
                    {
                        ErrorDialog ed = new ErrorDialog();
                        ed.post("Can not parse node comment at line {0} in file {1}", lineno, filename);
                        return true;
                    }
                    else
                    {
                        node_name = m.Groups[1].ToString();
                        instance = Int32.Parse(m.Groups[2].ToString());
                        x = Int32.Parse(m.Groups[3].ToString());
                        y = Int32.Parse(m.Groups[4].ToString());
                        labelstr = m.Groups[5].ToString();
                        n_inputs = InputCount;
                        n_outputs = OutputCount;
                    }
                }
                else
                {
                    node_name = m.Groups[1].ToString();
                    instance = Int32.Parse(m.Groups[2].ToString());
                    x = Int32.Parse(m.Groups[3].ToString());
                    y = Int32.Parse(m.Groups[4].ToString());
                    n_inputs = Int32.Parse(m.Groups[5].ToString());
                    labelstr = m.Groups[6].ToString();
                    n_outputs = OutputCount;
                }
            }
            else
            {
                node_name = m.Groups[1].ToString();
                instance = Int32.Parse(m.Groups[2].ToString());
                x = Int32.Parse(m.Groups[3].ToString());
                y = Int32.Parse(m.Groups[4].ToString());
                n_inputs = Int32.Parse(m.Groups[5].ToString());
                n_outputs = Int32.Parse(m.Groups[6].ToString());
                labelstr = m.Groups[7].ToString();
            }

            Symbol s = SymbolManager.theSymbolManager.registerSymbol(node_name);
            NodeDefinition nd;
            if (!NodeDefinition.theNodeDefinitionDictionary.TryGetValue(s, out nd) || nd == null)
            {
                ErrorDialog ed = new ErrorDialog();
                ed.post("Undefined module {0} at line {1} in file {2}", 
                    node_name, lineno, filename);
                return false;
            }

            setLabelString(labelstr);

            setInstanceNumber(instance);
            setVpePosition(x, y);

            // Count the inputs, if not the default and the inputs are repeatable 
	        // then add some inputs. If there are fewer inputs in the file, silently 
            // assume that this is an old network.

            if (n_inputs != InputCount)
            {
                if (isInputRepeatable())
                {
                    int delta_inputs = n_inputs - InputCount;
                    bool adding = delta_inputs > 0;
                    if (!adding)
                        delta_inputs = -delta_inputs;
                    int sets;
                    if (delta_inputs % InputRepeatCount != 0)
                    {
                        ErrorDialog ed = new ErrorDialog();
                        ed.post("Number of repeatable input parameters does not " +
                            "divide number of parameters for module {0}", NameString);
                        return true;
                    }
                    sets = delta_inputs / InputRepeatCount;
                    for (int i = 0; i < sets; i++)
                    {
                        if (adding)
                        {
                            if (!addInputRepeats())
                            {
                                ErrorDialog ed = new ErrorDialog();
                                ed.post("Can't add repeated input parameters");
                                return true;
                            }
                        }
                        else
                        {
                            if (!removeInputRepeats())
                            {
                                ErrorDialog ed = new ErrorDialog();
                                ed.post("Can't remove repeated input parameters");
                                return true;
                            }
                        }
                    }
                }
            }
            if (n_outputs != OutputCount)
            {
                if (isOutputRepeatable())
                {
                    int delta_outputs = n_outputs - OutputCount;
                    bool adding = delta_outputs > 0;
                    if (!adding)
                        delta_outputs = -delta_outputs;
                    int sets;
                    if (delta_outputs % OutputRepeatCount != 0)
                    {
                        ErrorDialog ed = new ErrorDialog();
                        ed.post("Number of repeatable output parameters does not " +
                            "divide number of parameters for module {0}", NameString);
                        return true;
                    }
                    sets = delta_outputs / OutputRepeatCount;
                    for (int i = 0; i < sets; i++)
                    {
                        if (adding)
                        {
                            if (!addOutputRepeats())
                            {
                                ErrorDialog ed = new ErrorDialog();
                                ed.post("Can't add repeated output parameters");
                                return true;
                            }
                        }
                        else
                        {
                            if (!removeOutputRepeats())
                            {
                                ErrorDialog ed = new ErrorDialog();
                                ed.post("Can't remove repeated output parameters");
                                return true;
                            }
                        }
                    }
                }
            }

            // Increment the module instance count if the current node
            // instance count is higher
            if (instance > definition.getCurrentInstance())
                definition.setNextInstance(instance + 1);

            return true;
        }

        /// <summary>
        /// These are called to parse any comments after the 'node', 'input',
        /// 'output' and 'pgrp'  comments in the .net file.
        /// </summary>
        /// <param name="comment"></param>
        /// <param name="filename"></param>
        /// <param name="lineno"></param>
        /// <returns></returns>
        protected virtual bool netParseAuxComment(String comment,
            String filename, int lineno)
        {
            return false;
        }

        protected String nodeNetNodeString(String prefix)
        {
            String name = definition.ExecModuleNameString;
            Debug.Assert(name != null);

            String outputs = outputParameterNamesString(prefix);

            String module = indent + name + "(";

            String inputs = inputParameterNamesString(prefix, indent);

            String gname = getGroupName(SymbolManager.theSymbolManager.getSymbol(ProcessGroupManager.ProcessGroup));

            String attributes;
            if (gname == null)
            {
                attributes = String.Format("{0}) [instance: {1}, cache: {2}];", indent,
                    instanceNumber, (long)nodeCacheability);
            }
            else
            {
                attributes = String.Format("{0}) [instance: {1}, cache: {2}, group: \"{3}\"];",
                    indent, instanceNumber, (long)nodeCacheability, gname);
            }
            String s = "";
            if (OutputCount != 0)
            {
                s = (outputs == null ? "" : outputs) + " = \n";
            }
            s += module + "\n";
            s += (inputs == null ? "" : inputs) + "\n";
            s += attributes;

            return s;
        }

        /// <summary>
        /// Create the invocation of the script language Node call. 
        /// The string that is returned should be deleted by the caller.
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns></returns>
        protected virtual String netNodeString(String prefix)
        {
            return nodeNetNodeString(prefix);
        }

        /// <summary>
        /// Create the invocation of any script language that is
        /// to occur at the beginning or end of the containing macro.
        /// The string that is returned should be deleted by the caller.
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns></returns>
        protected virtual String netBeginningOfMacroNodeString(String prefix)
        {
            return null;
        }
        protected virtual String netEndOfMacroNodeString(String prefix)
        {
            return null;
        }

        /// <summary>
        /// Put a parameter name/value ('name = value;') pair into a string if
        /// the parameter is a value.  They may return NULL if no strings are
        /// to be printed.
        /// </summary>
        /// <param name="i"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        protected virtual String inputValueString(int i, String prefix)
        {
            return ioValueString(inputParameters, i, prefix);
        }
        protected virtual String outputValueString(int i, String prefix)
        {
            return ioValueString(outputParameters, i, prefix);
        }
        /// <summary>
        /// Some other node sub-subclasses need to call this parent method.
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns></returns>
        protected String nodeValuesString(String prefix)
        {
            String s = "";

            if (!network.IsMacro)
            {
                for (int i = 1; i <= InputCount; i++)
                {
                    String buf = inputValueString(i, prefix);
                    if (buf != null)
                        s += buf + "\n";
                }
            }
            for (int i = 1; i <= OutputCount; i++)
            {
                String buf = outputValueString(i, prefix);
                if (buf != null)
                    s += buf + "\n";
            }

            if (s.Length == 0)
                return null;

            return s;
        }

        protected virtual String valuesString(String prefix)
        {
            return nodeValuesString(prefix);
        }

        /// <summary>
        /// Set the index'th i/o parameter to use either the default value 
        /// or the assigned valued. if notify is TRUE then call 
        /// ioParameterStatusChanged() with Node::ParameterSetValueToDefaulting.
        /// If there is a connection to the executive, then send the change.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="input"></param>
        /// <param name="defaulting"></param>
        protected void setIODefaultingStatus(int index, bool input,
            bool defaulting)
        {
            setIODefaultingStatus(index, input, defaulting, true, true);
        }
        protected void setIODefaultingStatus(int index, bool input,
            bool defaulting, bool send)
        {
            setIODefaultingStatus(index, input, defaulting, send, true);
        }
        protected void setIODefaultingStatus(int index, bool input,
            bool defaulting, bool send, bool notify)
        {
            Parameter p;
            if (input)
                p = getInputParameter(index);
            else
                p = getOutputParameter(index);

            bool was_defaulting = p.IsDefaulting;
            if (was_defaulting == defaulting)
                return;

            p.setUnconnectedDefaultingStatus(defaulting);

            // And now send the value to the executive if there is a connection.
            // Note that we don't need to set the network dirty, because we can
            // send the changes ourselves.
            if (send)
            {
                DXPacketIF pif = DXApplication.theDXApplication.getPacketIF();
                if (pif != null)
                    sendValues(false);
            }

            Debug.Assert(!p.IsConnected);
            if (notify)
                this.notifyIoParameterStatusChanged(input, index, 
                    NodeParameterStatusChange.ParameterSetValueToDefaulting);
        }

        /// <summary>
        /// Notify anybody that needs to know that a parameter has changed its
        /// value or arcs.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="index"></param>
        /// <param name="status"></param>
        protected virtual void ioParameterStatusChanged(bool input, int index,
            NodeParameterStatusChange status)
        {
            // If we have Configuration Dialog, let it know the value, arc or 
            // visibility was changed.
            if (cdb != null)
            {
                if (input)
                    cdb.changeInput(index);
                else
                    cdb.changeOutput(index);
            }

            // Now notify all nodes receiving this output that the value has changed.
            if (!input && ((long)(status & NodeParameterStatusChange.ParameterValueChanged) > 0))
            {
                foreach (Ark a in getOutputArks(index))
                {
                    int in_index = 0;
                    Node n = a.getDestinationNode(out in_index);
                    n.notifyIoParameterStatusChanged(true, in_index, status);
                }
            }

            // Let the standin know about this. We don't notify StandIns about
            // arc changes since they are the ones that generate them. 
            if (standin != null && ((long)(status & NodeParameterStatusChange.ParameterArkChanged) == 0))
                standin.ioStatusChange(index, !input, status);

            // Tell the network that it has changed. 

            // If this is an input and the tool is in a macro, then we must always
            // resend the macro defnition because input values are contained within
            // the macro definition.  Otherwise we only need to mark the network
            // dirty if an arc has changed.
            if (input && network.IsMacro)
                network.setDirty();
            else
            {
                if ((long)(status & NodeParameterStatusChange.ParameterArkChanged) > 0)
                    network.setDirty();
                else
                    network.setFileDirty();
            }
        }

        /// <summary>
        /// notifyIo is the same as io sort of.  notifyIo adds a check to see
        /// if the network is in the process of going away.  That avoids useless work.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="index"></param>
        /// <param name="status"></param>
        protected void notifyIoParameterStatusChanged(bool input, int index,
            NodeParameterStatusChange status)
        {
            if (!network.IsDeleted)
                ioParameterStatusChanged(input, index, status);
        }


        /// <summary>
        /// Used by netPrintNode() to print the Names of it's input and output 
        /// parameters.  In the case of inputs, if the input is taking output
        /// from another source (i.e it has an arc), then we print the name
        /// of that output instead.
        /// </summary>
        /// <param name="varprefix"></param>
        /// <returns></returns>
        protected virtual String inputParameterNamesString(String varprefix)
        {
            return inputParameterNamesString(varprefix, null);
        }
        protected virtual String inputParameterNamesString(String varprefix,
            String indent)
        {
            String name = NameString;
            Debug.Assert(name != null);

            int num_params = inputParameters.Count;
            if (num_params == 0)
                return null;

            if (indent == null)
                indent = "";

            String retstr = "";

            for (int i = 1; i <= num_params; i++)
            {
                String buf = "";
                Parameter p = getInputParameter(i);
                if (p.IsConnected)
                {
                    Ark a = p.getArk(1);
                    Debug.Assert(a != null);
                    int param;
                    Node onode = a.getSourceNode(out param);
                    Debug.Assert(onode != null);
                    buf = indent + varprefix + onode.NameString + "_" + onode.InstanceNumber.ToString() +
                        "_out_" + param.ToString();
                }
                else
                {
                    if (network.IsMacro)
                        buf = indent + getInputValueString(i);
                    else
                        buf = indent + varprefix + name + "_" + instanceNumber.ToString() + "_in_" +
                            i.ToString();
                }
                if (i != num_params)
                    buf += ",\n";

                retstr += buf;
            }
            return retstr;
        }

        protected virtual String outputParameterNamesString(String prefix)
        {
            if (OutputCount == 0)
                return null;

            String name = NameString;
            Debug.Assert(name != null);

            int num_params = outputParameters.Count;

            String newprefix = prefix + name + "_" + instanceNumber.ToString() + "_out_";
            String retstr = "";

            for (int i = 1; i <= num_params; i++)
            {
                Parameter p = getOutputParameter(i);
                Debug.Assert(p != null);
                String buf = "";

                if (getNodeCacheability() == p.getCacheability())
                    buf = newprefix + i.ToString() + (i == num_params ? "" : ",\n");
                else
                    buf = newprefix + i.ToString() + "[cache: " + ((int)p.getCacheability()).ToString() +
                        (i == num_params ? "" : ",\n");

                retstr += buf;
            }
            return retstr;
        }

        protected bool netPrintCommentHeader(StreamWriter s)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected virtual bool printIOComment(StreamWriter s, bool input, int index)
        {
            return printIOComment(s, input, index, null, false);
        }
        protected virtual bool printIOComment(StreamWriter s, bool input, int index,
            String indent)
        {
            return printIOComment(s, input, index, indent, false);
        }
        protected virtual bool printIOComment(StreamWriter s, bool input, int index,
            String indent, bool valueOnly)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected bool netPrintPgrpComment(StreamWriter s)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected virtual bool netPrintAuxComment(StreamWriter s)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Called when a message is received from the executive after
        /// this->ExecModuleMessageHandler() is registered in 
        /// this->Node::netPrintNode() to receive messages for this node.  
        /// The format of the message coming back is defined by the derived class.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="line"></param>
        protected virtual void execModuleMessageHandler(int id, String line)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Update the state of message handling for a module/UI message.
        /// This is called only when we send a Node's module call to the executive
        /// and the node has a module messaging protocol as defined by
        /// this->hasModuleMessageProtocol().
        /// </summary>
        /// <param name="pif"></param>
        protected virtual void updateModuleMessageProtocol(DXPacketIF pif)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return TRUE/FALSE, indicating whether or not we support a message 
        /// protocol between the executive module that runs for this node and the
        /// UI.  By default Nodes do not have message protocols.
        /// </summary>
        /// <returns></returns>
        protected virtual bool hasModuleMessageProtocol()
        {
            return false;
        }

        /// <summary>
        /// Return TRUE/FALSE, indicating whether or not we expect to receive
        /// a message from the UI when our module executes in the executive.
        /// Be default Nodes do not expect messages.
        /// </summary>
        /// <returns></returns>
        protected virtual bool expectingModuleMessage()
        {
            return false;
        }

        /// <summary>
        /// Returns a string that is used to register 
        /// this->ExecModuleMessageHandler() when this->hasModuleMessageProtocol() 
        /// return TRUE.  This version, returns an id that is unique to this 
        /// instance of this node.
        ///
        /// IMPORTANT: this must set this->moduleMessageId so that Node::~Node()
        ///		can know the id string. 
        /// </summary>
        /// <returns></returns>
        protected virtual String getModuleMessageIdString()
        {
            if (moduleMessageId == null)
            {
                String name = NameString;
                name += "_" + InstanceNumber.ToString();
                moduleMessageId = name;
            }

            return moduleMessageId;
        }

        /// <summary>
        /// Do any work that must be done before sending the macro/network
        /// that this node belongs to to the server.
        /// Be default, Nodes do not have any work that needs to be done 
        /// before sending.
        /// </summary>
        protected virtual void prepareToSendNode()
        {
            //Intentionally left blank
        }

        /// <summary>
        /// Do any work that must be done before sending the given parameter value 
        /// to the server. 
        /// Be default, Nodes do not have any work that needs to be done 
        /// before sending parameter values.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="p"></param>
        protected virtual void prepareToSendValue(int index, Parameter p)
        {
            //Intentionally left blank
        }

        /// <summary>
        /// See if the given string is a viable label to be used as an identifier.
        /// Also make sure it is not a reserved script language word.
        /// Return TRUE if ok, FALSE otherwise and issue and error message.
        /// </summary>
        /// <param name="label"></param>
        /// <returns></returns>
        protected bool verifyRestrictedLabel(String label)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Print/parse the 'node %s[%d]:' comment.
        /// Not all nodes have cfg info, but it is provided for those that do.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        protected bool cfgPrintNodeLeader(Stream s)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected bool cfgParseNodeLeader(String comment,
            String file, int lineno)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected virtual void setIOCacheability(List<Parameter> io, int index, Cacheability c)
        {
            Parameter p;
            Debug.Assert(index >= 1);

            p = io[index - 1];
            Debug.Assert(p != null);

            if (c != p.getCacheability())
            {
                bool r = isIOCacheabilityWriteable(io, index);
                Debug.Assert(r);

                p.setCacheability(c);
                getNetwork().setDirty();
                if (cdb != null)
                    cdb.changeOutput(index);
            }
        }

        #endregion

        #region Public Methods

        public Node(NodeDefinition nd, Network net, int inst)
        {
            network = net;
            instanceNumber = inst;
            setDefinition(nd);
            vpe_xpos = vpe_ypos = 0;
            labelSymbol = Symbol.zero;
            standin = null;
            cdb = null;
            moduleMessageId = null;
            nodeCacheability = nd.DefaultCacheability;
            buildParameterLists();
            marked = false;
            layout_information = null;
        }

        /// <summary>
        /// Generate a new instance number for this node.  We notify the
        /// standIn and mark the network and the node dirty.
        /// The new instance number is returned.
        /// </summary>
        /// <returns></returns>
        public virtual int assignNewInstanceNumber()
        {
            throw new Exception("Not Yet Implemented");
        }


        public void setMarked() { this.marked = true; }
        public void clearMarked() { this.marked = false; }


        public virtual void setDefinition(NodeDefinition nd)
        {
            definition = nd;
            if (instanceNumber < 1)
                instanceNumber = nd.newInstanceNumber();
        }
        public virtual void updateDefinition()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Build a Node's input and output parameter lists based on this
        /// node definition.
        /// </summary>
        /// <returns></returns>
        public bool buildParameterLists()
        {
            int ninputs, noutputs, i;
            Parameter p;
            ParameterDefinition pd;
            NodeDefinition nd = Definition;
            ninputs = nd.InputCount;

            for (i = 1; i <= ninputs; i++)
            {
                pd = nd.getInputDefinition(i);
                Debug.Assert(pd != null);

                p = nd.newParameter(pd, this, i);
                Debug.Assert(p != null);

                bool r = appendInput(p);
                Debug.Assert(r); // FIXME: handle error
            }
            if (nd.IsInputRepeatable)
                addRepeats(true);

            noutputs = nd.OutputCount;
            for (i = 1; i <= noutputs; i++)
            {
                pd = nd.getOutputDefinition(i);
                Debug.Assert(pd != null);

                p = nd.newParameter(pd, this, i);
                Debug.Assert(p != null);

                bool r = appendOutput(p);
                Debug.Assert(r);
            }
            if (nd.IsOutputRepeatable)
                addRepeats(false);

            return true;
        }

        /// <summary>
        /// Perform any additional initializations that were not performed
        /// in the constrctor.  If this returns TRUE initialization was 
        /// successful, otherwise FALSE.  If FALSE, then it is assumed that
        /// initialize() will issue the error/warning message. 
        /// initialize() is called before the Node is actually added to the
        /// Network.
        /// </summary>
        /// <returns></returns>
        public virtual bool initialize()
        {
            return true;
        }


        /// <summary>
        /// initializeAfterNodeMember() is called after initialize() but after the 
        /// Node is actually added to the Network.
        /// </summary>
        public virtual void initializeAfterNetworkMember()
        {
            // no implementation
        }


        public virtual Symbol getNameSymbol()
        {
            return this.definition.NameSymbol;
        }

        /// <summary>
        /// Non-virtualized method of setLabelString so sub-sub classes can call it.
        /// </summary>
        /// <param name="label"></param>
        /// <returns></returns>
        public bool nodeSetLabelString(String label)
        {
            labelSymbol = SymbolManager.theSymbolManager.registerSymbol(label);
            if (cdb != null)
                cdb.changeLabel();
            if (getStandIn() != null)
                getStandIn().notifyLabelChange();
            return true;
        }

        public virtual bool setLabelString(String label)
        {
            labelSymbol = SymbolManager.theSymbolManager.registerSymbol(label);
            if (cdb != null)
                cdb.changeLabel();
            if (getStandIn() != null)
                getStandIn().notifyLabelChange();
            return true;
        }
        public virtual String LabelString
        {
            get
            {
                throw new Exception("Not Yet Implemented");
            }
        }

        public void setVpePosition(int x, int y)
        {
            vpe_xpos = x;
            vpe_ypos = y;
            if (standin != null)
                standin.Location = new System.Drawing.Point(x, y);
        }

        /// <summary>
        /// Add/remove a set of input our output parameters to the give model.
        /// </summary>
        /// <returns></returns>
        public bool addInputRepeats() { return addRepeats(true); }
        public bool removeInputRepeats() { return removeRepeats(true); }
        public bool addOutputRepeats() { return addRepeats(false); }
        public bool removeOutputRepeats() { return removeRepeats(false); }


        public bool hasExposableInput()
        {
            return hasExposableIO(inputParameters);
        }
        public bool hasExposableOutput()
        {
            return hasExposableIO(outputParameters);
        }
        public bool hasHideableInput()
        {
            return hasHideableIO(inputParameters);
        }
        public bool hasHideableOutput()
        {
            return hasHideableIO(outputParameters);
        }

        public bool hasRemovableInput()
        {
            throw new Exception("Not Yet Implemented");
        }
        public bool hasRemovableOutput()
        {
            throw new Exception("Not Yet Implemented");
        }
        public bool isInputRepeatable()
        {
            NodeDefinition def = Definition;
            if (!def.IsInputRepeatable)
                return false;
            int icnt = InputCount;
            int rcnt = icnt - (def.InputCount - def.InputRepeatCount);
            int sets = rcnt / def.InputRepeatCount;
            return (sets < MAX_INPUT_SETS);
        }
        public bool isOutputRepeatable()
        {
            NodeDefinition def = Definition;
            if (!def.IsOutputRepeatable)
                return false;
            int icnt = OutputCount;
            int rcnt = icnt - (def.OutputCount - def.OutputRepeatCount);
            int sets = rcnt / def.OutputRepeatCount;
            return (sets < MAX_OUTPUT_SETS);
        }

        // Manage inputs
        public bool addInputArk(Ark a, int index)
        {
            return addIOArk(inputParameters, index, a);
        }
        public bool addOutputArk(Ark a, int index)
        {
            return addIOArk(outputParameters, index, a);
        }

        public List<Ark> getInputArks(int index)
        {
            return getIOArks(inputParameters, index);
        }

        public List<Ark> getOutputArks(int index)
        {
            return getIOArks(outputParameters, index);
        }

        public virtual bool deleteArk(Ark a)
        {
            throw new Exception("Not Yet Implemented");
        }


        public String getInputValueString(int index)
        {
            return getIOValueString(inputParameters, index);
        }
        public String getOutputValueString(int index)
        {
            return getIOValueString(outputParameters, index);
        }
        public DXTypeVals getInputSetValueType(int index)
        {
            return getIOSetValueType(inputParameters, index);
        }
        public DXTypeVals getOutputSetValueType(int index)
        {
            return getIOSetValueType(outputParameters, index);
        }


        public String getInputNameString(int index)
        {
            return getIONameString(inputParameters, index);
        }
        public String getOutputNameString(int index)
        {
            return getIONameString(outputParameters, index);
        }

        /// <summary>
        /// Get the name of the input as specified in the network
        /// (i.e. main_Display_1_in_3)
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public String getNetworkInputNameString(int index)
        {
            return getNetworkIONameString(index, true);
        }
        public String getNetworkOutputNameString(int index)
        {
            return getNetworkIONameString(index, false);
        }

        public String[] getInputTypeStrings(int index)
        {
            return getIOTypeStrings(inputParameters, index);
        }
        public String[] getOutputTypeStrings(int index)
        {
            return getIOTypeStrings(outputParameters, index);
        }


        public List<DXType> getInputTypes(int index)
        {
            return getIOTypes(inputParameters, index);
        }
        public List<DXType> getOutputTypes(int index)
        {
            return getIOTypes(outputParameters, index);
        }


        public String getInputDescription(int index)
        {
            return getIODescription(inputParameters, index);
        }
        public String getOutputDescription(int index)
        {
            return getIODescription(outputParameters, index);
        }

        public String getInputDefaultValueString(int index)
        {
            return getIODefaultValueString(inputParameters, index);
        }

        public String getInputSetValueString(int index)
        {
            return getIOSetValueString(inputParameters, index);
        }

        public bool isInputRequired(int index)
        {
            return isIORequired(inputParameters, index);
        }
        public bool isOutputRequired(int index)
        {
            return isIORequired(outputParameters, index);
        }

        public bool isInputConnected(int index)
        {
            return isIOConnected(inputParameters, index);
        }
        public bool isOutputConnected(int index)
        {
            return isIOConnected(outputParameters, index);
        }
        public bool isParameterConnected(int index, bool input)
        {
            return (input ? isIOConnected(inputParameters, index) :
                isIOConnected(outputParameters, index));
        }

        public void setInputVisibility(int index, bool v)
        {
            setIOVisibility(inputParameters, index, v);
        }
        public void setOutputVisibility(int index, bool v)
        {
            setIOVisibility(outputParameters, index, v);
        }

        public void setAllInputsVisibility(bool v)
        {
            setAllIOVisibility(inputParameters, v);
        }
        public void setAllOutputsVisibility(bool v)
        {
            setAllIOVisibility(outputParameters, v);
        }

        public void clearInputDirty(int index)
        {
            setIODirty(ref inputParameters, index, false);
        }
        public void setInputDirty(int index)
        {
            setIODirty(ref inputParameters, index, true);
        }
        public void clearOutputDirty(int index)
        {
            setIODirty(ref outputParameters, index, false);
        }
        public void setOutputDirty(int index)
        {
            setIODirty(ref outputParameters, index, true);
        }

        public bool isInputVisible(int index)
        { return isIOVisible(inputParameters, index); }
        public bool isOutputVisible(int index)
        { return isIOVisible(outputParameters, index); }
        public bool isParameterVisible(int index, bool input)
        {
            return (input ? isInputVisible(index) : isOutputVisible(index));
        }

        public bool isInputViewable(int index)
        {
            return isIOViewable(inputParameters, index);
        }
        public bool isOutputViewable(int index)
        {
            return isIOViewable(outputParameters, index);
        }
        public bool isParameterViewable(int index, bool input)
        {
            return (input ? isInputViewable(index) : isOutputViewable(index));
        }

        public Cacheability getOutputCacheability(int index)
        {
            return getIOCacheability(outputParameters, index);
        }
        public void setOutputCacheability(int index, Cacheability c)
        {
            setIOCacheability(outputParameters, index, c);
        }
        public bool isOutputCacheabilityWriteable(int index)
        {
            return isIOCacheabilityWriteable(outputParameters, index);
        }

        public bool isInputDefaulting(int index)
        { return isIODefaulting(inputParameters, index); }

        public bool isInputSet(int index)
        { return isIOSet(inputParameters, index); }


        // Match output_index of this node tho input_index of n. Returns true
        // if they can connect.
        public virtual bool typeMatchOutputToInput(int output_index, Node n, int input_index)
        {
            throw new Exception("Not Yet Implemented");
        }

        // Set the stored value.
        // If the parameter is not defaulting, this is
        // the same as setValue, but if it is defaulting, then we set the
        // value but leave the parameter clean and defaulting and ignore send.
        public virtual DXTypeVals setInputSetValue(int index, String value)
        {
            return setInputSetValue(index, value, DXTypeVals.UndefinedType, true);
        }
        public virtual DXTypeVals setInputSetValue(int index, String value, DXTypeVals type)
        {
            return setInputSetValue(index, value, type, true);
        }
        public virtual DXTypeVals setInputSetValue(int index, String value, DXTypeVals type,
            bool send)
        {
            bool was_defaulting = isInputDefaulting(index);

            // If the parameter is already set (i.e. tab down) then just do
            // a normal set and return.
            if (!was_defaulting)
                return setInputValue(index, value, type, send);

            // First set the value, don't send it and don't do notification (this
            // is the same as a normal set except we don't do notification).
            type = setIOValue(ref inputParameters, index, value, type, false, false);

            if (type != DXTypeVals.UndefinedType)
            {
                // Second, set the parameter back to defaulting, but again, don't
                // do notification (again, this is the same as a normal setting of 
                // a parameter to defaulting, but no notification).
                setIODefaultingStatus(index, true, true, false, false);

                // Third, clear the parameter's dirty bit as we are only changing
                // the set value (i.e. not the value the exec knows about).
                clearInputDirty(index);

                // Now do the notification that we've jumped through hoops to
                // get right!
                notifyIoParameterStatusChanged(true, index, NodeParameterStatusChange.PatemeterSetValueChanged);
            }
            return type;
        }

        public virtual DXTypeVals setInputValue(int index, String value)
        {
            return setInputValue(index, value, DXTypeVals.UndefinedType, true);
        }
        public virtual DXTypeVals setInputValue(int index, String value, DXTypeVals type)
        {
            return setInputValue(index, value, type, true);
        }
        public virtual DXTypeVals setInputValue(int index, String value, DXTypeVals type,
            bool send)
        {
            return setIOValue(ref inputParameters, index, value, type, send);
        }

        public virtual DXTypeVals setOutputValue(int index, String value)
        {
            return setOutputValue(index, value, DXTypeVals.UndefinedType, true);
        }
        public virtual DXTypeVals setOutputValue(int index, String value, DXTypeVals type)
        {
            return setOutputValue(index, value, type, true);
        }
        public virtual DXTypeVals setOutputValue(int index, String value, DXTypeVals type,
            bool send)
        {
            return setIOValue(ref outputParameters, index, value, type, send);
        }

        /// <summary>
        /// These are the same as setInputValue and setOutputValue, but they send
        /// the value to the executive without causing an executive execution in 
        /// execute on change.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public virtual DXTypeVals setInputValueQuietly(int index, String value)
        {
            return setInputValueQuietly(index, value, DXTypeVals.UndefinedType);
        }
        public virtual DXTypeVals setInputValueQuietly(int index, String value, DXTypeVals t)
        {
            return setIOValueQuietly(ref inputParameters, index, value, t);
        }

        public virtual DXTypeVals setOutputValueQuietly(int index, String value)
        {
            return setIOValueQuietly(ref outputParameters, index, value, DXTypeVals.UndefinedType);
        }
        public virtual DXTypeVals setOutputValueQuietly(int index, String value, DXTypeVals t)
        {
            return setIOValueQuietly(ref outputParameters, index, value, t);
        }

        public virtual DXTypeVals clearOutputValue(int index)
        {
            return setIOValue(ref outputParameters, index, null, DXTypeVals.UndefinedType, true);
        }
        public virtual DXTypeVals clearOutputValue(int index, bool send)
        {
            return setIOValue(ref outputParameters, index, null, DXTypeVals.UndefinedType, send);
        }

        public void getVpePosition(out int x, out int y)
        {
            if (this.standin != null)
            {
                x = standin.Location.X;
                y = standin.Location.Y;
                vpe_xpos = x;
                vpe_ypos = y;
            }
            else
            {
                x = vpe_xpos;
                y = vpe_ypos;
            }
        }

        /// <summary>
        /// Parse routines for a node, called by a Network. 
        /// These are called for the comments found in the .net and .cfg files
        /// respectively. 
        /// </summary>
        /// <param name="comment"></param>
        /// <param name="file"></param>
        /// <param name="lineno"></param>
        /// <returns></returns>
        public virtual bool netParseComment(String comment, String file, int lineno)
        {
            Debug.Assert(comment != null);

            return netParseNodeComment(comment, file, lineno) ||
                parseIOComment(true, comment, file, lineno) ||
                parseIOComment(false, comment, file, lineno) ||
                parseGroupComment(comment, file, lineno) ||
                netParseAuxComment(comment, file, lineno);
        }
        public virtual bool cfgParseComment(String comment, String file, int lineno)
        {
            return cfgParseNodeLeader(comment, file, lineno);
        }

        /// <summary>
        /// Print the stuff that belongs in a .cfg file
        /// </summary>
        /// <param name="sw"></param>
        /// <param name="destination"></param>
        /// <returns></returns>
        public virtual bool cfgPrintNode(StreamWriter sw, PrintType destination)
        {
            return true;
        }

        /// <summary>
        /// Print the invocation of the script language Node call. 
        /// </summary>
        /// <param name="sw"></param>
        /// <param name="destination"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        public bool netPrintNode(StreamWriter sw, PrintType destination, String prefix)
        {
            return netPrintNode(sw, destination, prefix, null, null);
        }
        public bool netPrintNode(StreamWriter sw, PrintType destination, String prefix,
            PacketIF.PacketIFCallback callback)
        {
            return netPrintNode(sw, destination, prefix, callback, null);
        }
        public bool netPrintNode(StreamWriter sw, PrintType destination, String prefix,
            PacketIF.PacketIFCallback callback, Object clientdata)
        {
            DXPacketIF pif = DXApplication.theDXApplication.getPacketIF();
            bool r = true;

            if (destination == PrintType.PrintFile || destination == PrintType.PrintCut ||
                destination == PrintType.PrintCPBuffer)
            {
                if (!netPrintCommentHeader(sw))
                    return false;
            }
            else if (pif != null)
            {
                // We have a connection to the executive/server
                //
                // If this node has a message protocol with the executive, then
                // update any state associated with the protocol.
                if (hasModuleMessageProtocol())
                    updateModuleMessageProtocol(pif);

                prepareToSendNode();
            }
            String s = netNodeString(prefix);

            if (destination == PrintType.PrintFile || destination == PrintType.PrintCut ||
                destination == PrintType.PrintCPBuffer)
            {
                sw.Write(s);
                if (callback != null)
                    callback(clientdata, s);
            }
            else
            {
                Debug.Assert(destination == PrintType.PrintExec);
                pif.sendBytes(s);
            }

            return r;
        }

        /// <summary>
        /// Print the invocation of any script language that is to occur at the beginning 
        /// of the containing macro.
        /// </summary>
        /// <param name="sw"></param>
        /// <param name="destination"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        public bool netPrintBeginningOfMacroNode(StreamWriter sw, PrintType destination,
            String prefix)
        {
            return netPrintBeginningOfMacroNode(sw, destination, prefix, null, null);
        }
        public bool netPrintBeginningOfMacroNode(StreamWriter sw, PrintType destination,
            String prefix, PacketIF.PacketIFCallback callback)
        {
            return netPrintBeginningOfMacroNode(sw, destination, prefix, callback, null);
        }
        public bool netPrintBeginningOfMacroNode(StreamWriter sw, PrintType destination,
            String prefix, PacketIF.PacketIFCallback callback, Object clientdata)
        {
            String s = netBeginningOfMacroNodeString(prefix);
            if (s == null)
                return true;

            if (destination == PrintType.PrintFile || destination == PrintType.PrintCut ||
                destination == PrintType.PrintCPBuffer)
            {
                sw.Write(s);
                if (callback != null)
                    callback(clientdata, s);
            }
            else
            {
                DXApplication.theDXApplication.getPacketIF().sendBytes(s);
            }

            return true;
        }

        /// <summary>
        /// Print the invocation of any script language that is to occur at the end of the 
        /// containing macro.
        /// </summary>
        /// <param name="sw"></param>
        /// <param name="destination"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        public bool netPrintEndOfMacroNode(StreamWriter sw, PrintType destination,
            String prefix)
        { return netPrintEndOfMacroNode(sw, destination, prefix, null, null); }
        public bool netPrintEndOfMacroNode(StreamWriter sw, PrintType destination,
            String prefix, PacketIF.PacketIFCallback callback)
        { return netPrintEndOfMacroNode(sw, destination, prefix, callback, null); }
        public bool netPrintEndOfMacroNode(StreamWriter sw, PrintType destination,
            String prefix, PacketIF.PacketIFCallback callback, Object clientdata)
        {
            bool r = true;

            String s = netEndOfMacroNodeString(prefix);
            if (s == null)
                return true;

            if (destination == PrintType.PrintFile || destination == PrintType.PrintCut ||
                destination == PrintType.PrintCPBuffer)
            {
                sw.Write(s);
                if (callback != null)
                    callback(clientdata, s);
            }
            else
            {
                Debug.Assert(destination == PrintType.PrintExec);
                DXPacketIF pif = DXApplication.theDXApplication.getPacketIF();
                pif.sendBytes(s);
            }

            return r;
        }


        /// <summary>
        /// Save any other files that relevant to this mode 
        /// The name passed in is file name used to save the network (without the
        /// .net extension). 
        /// </summary>
        /// <returns></returns>
        public virtual bool auxPrintNodeFile()
        {
            throw new Exception("Not Yet Implemented");
        }


        /// <summary>
        /// Print parameter name/value ('name,name = value,value;') pairs.
        /// </summary>
        /// <param name="sw"></param>
        /// <param name="prefix"></param>
        /// <param name="dest"></param>
        /// <returns></returns>
        public virtual bool printValues(StreamWriter sw, String prefix, PrintType dest)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// For inputs, outputs or both sets of parameters send the values
        /// for of which do not have arcs. 
        /// </summary>
        /// <returns></returns>
        public virtual bool sendValues() { return sendValues(true); }
        public virtual bool sendValues(bool ignoreDirty)
        {
            DXPacketIF pif = DXApplication.theDXApplication.getPacketIF();
            String names = "";
            String values = "";

            if (pif == null)
                return true;

            String prefix = network.getPrefix();
            int cnt = InputCount;
            bool valAdded = false;

            if (!network.IsMacro)
            {
                for (int i = 1; i <= cnt; i++)
                {
                    Parameter p = inputParameters[i - 1];
                    if (p == null)
                        break;
                    if (p.IsNeededValue(ignoreDirty))
                    {
                        // Do any work that is necessary before sending the value.
                        prepareToSendValue(i, p);
                        names += (valAdded ? ", " : "") + strcatParameterNameLvalue(p, prefix, i);

                        values += (valAdded ? ", " : "") + strcatParameterValueString(p, i);
                        valAdded = true;
                        p.clearDirty();
                    }
                }
            }

            cnt = OutputCount;
            for (int i = 1; i <= cnt; i++)
            {
                Parameter p = outputParameters[i - 1];
                if (p == null)
                    break;
                if (p.IsNeededValue(ignoreDirty))
                {
                    prepareToSendValue(i, p);

                    names += (valAdded ? ", " : "") + strcatParameterNameLvalue(p, prefix, i);

                    values += (valAdded ? ", " : "") + strcatParameterValueString(p, i);
                    valAdded = true;
                    p.clearDirty();
                }
            }
            if (names.Length > 0)
            {
                String s = names + " = " + values + ";";
                pif.send(PacketIF.PacketType.FOREGROUND, s);
            }
            return true;
        }

        /// <summary>
        /// Send all dirty input and output values to the executive in the
        /// quiet way using the Executive("assign noexecute",...); call.
        /// </summary>
        public void sendValuesQuietly()
        {
            DXPacketIF pif = DXApplication.theDXApplication.getPacketIF();

            String msg;
            String varname;
            String varval;

            if (pif == null)
                return;

            for (int i = 1; i <= InputCount; i++)
            {
                Parameter p = getInputParameter(i);
                if (p.IsNeededValue(false))
                {
                    varname = getNetworkInputNameString(i);
                    varval = getInputValueString(i);
                    msg = String.Format("Executive(\"assign noexecute\", \"{0}\", {1});",
                        varname, varval);
                    pif.send(PacketIF.PacketType.FOREGROUND, msg);
                    p.clearDirty();
                }
            }
            for (int i = 1; i <= OutputCount; i++)
            {
                Parameter p = getOutputParameter(i);
                if (p.IsNeededValue(false))
                {
                    varname = getNetworkOutputNameString(i);
                    varval = getOutputValueString(i);
                    msg = String.Format("Executive(\"assign noexecute\", \"{0}\", {1};",
                        varname, varval);
                    pif.send(PacketIF.PacketType.FOREGROUND, msg);
                    p.clearDirty();
                }
            }
        }

        /// <summary>
        /// Manipulate the standin for this node.
        /// </summary>
        /// <param name="w"></param>
        /// <returns></returns>
        public StandIn newStandIn(WorkSpace w)
        {
            standin = SIAllocatorDictionary.theSIAllocatorDictionary.allocate(
                getNameSymbol(), w, this);
            return standin;
        }
        public StandIn getStandIn() { return this.standin; }


        public ConfigurationDialog newConfigurationDialog(Form f)
        {
            if (cdb == null)
                cdb = CDBAllocatorDictionary.theCDBAllocatorDictionary.allocate(
                    getNameSymbol(), f, this);
            return cdb;
        }

        public ConfigurationDialog getConfigurationDialog() { return cdb; }

        /// <summary>
        /// Perform the default function that is associated with the 
        /// StandIn's default event.
        /// </summary>
        /// <param name="parent"></param>
        public virtual void openDefaultWindow(Form parent)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Let the caller of openDefaultWindow() know what kind of window she's getting.
        /// This is intended for use in EditorWindow so that we can sanity check the number
        /// of cdbs were going to open before kicking off the operation and so that we
        /// don't question the user before opening large numbers of interactors.
        /// A name describing the type of window can be written into window_name in order
        /// to enable nicer warning messages.
        /// </summary>
        /// <returns></returns>
        public virtual bool defaultWindowIsCDB() { return true; }
        public virtual bool defaultWindowIsCDB(ref String window_name)
        {
            window_name = "Configuration Dialog";
            return true;
        }


        /// <summary>
        /// Open this node's cdb.
        /// </summary>
        /// <param name="f"></param>
        public virtual void openConfigurationDialog(Form f)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Display help for this node in a window.
        /// </summary>
        /// <param name="f"></param>
        public virtual void openHelpWindow(Form f)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Returns false for most nodes and is overridden by InteractorNode and
        /// MacroNode.
        /// </summary>
        /// <returns></returns>
        public virtual bool IsAllowedInMacro()
        {
            return definition.IsAllowedInMacro();
        }

        /// <summary>
        /// Manipulate whether the default value or assigned value is used 
        /// as the value for i/o parameter i.
        /// </summary>
        /// <param name="index"></param>
        public void useDefaultInputValue(int index)
        {
            setIODefaultingStatus(index, true, true, true);
        }
        public void useDefaultInputValue(int index, bool send)
        {
            setIODefaultingStatus(index, true, true, send);
        }

        public void useAssignedInputValue(int index)
        {
            setIODefaultingStatus(index, true, false, true);
        }
        public void useAssignedInputValue(int index, bool send)
        {
            setIODefaultingStatus(index, true, false, send);
        }

        public void useDefaultOutputValue(int index)
        {
            setIODefaultingStatus(index, false, true, true);
        }
        public void useDefaultOutputValue(int index, bool send)
        {
            setIODefaultingStatus(index, false, true, send);
        }

        public void useAssignedOutputValue(int index)
        {
            setIODefaultingStatus(index, false, false, true);
        }
        public void useAssignedOutputValue(int index, bool send)
        {
            setIODefaultingStatus(index, false, false, send);
        }


        public bool isA(String classname)
        {
            throw new Exception("Not Yet Implemented");
        }
        public virtual bool isA(Symbol classname)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Reset the node to using the default cfg state (probably before reading
        /// in a new cfg file).  In general, the only state that should be reset
        /// here is state that is saved in .cfg files.
        /// </summary>
        public virtual void setDefaultCfgState()
        {
            // Nothing purposely here.
        }

        /// <summary>
        /// Return TRUE if this node has state that will be saved in a .cfg file.
        /// At this level, nodes do not have cfg state.
        /// </summary>
        /// <returns></returns>
        public virtual bool hasCfgState()
        {
            return false;
        }

        /// <summary>
        /// Disconnect all input and output arcs from this node.
        /// </summary>
        /// <returns></returns>
        public bool disconnectArks()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return TRUE if the node can be switched (pasted/merged/moved) from 
        /// the 'from' net to the 'to' net.
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <returns></returns>
        public virtual bool canSwitchNetwork(Network from, Network to)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Switch the node's net from 'from' to 'to'
        /// 'silently' added 11/10/02 to support EditorWindow's undo.  We might be
        /// merging network elements some of which are going to be discarded.  We
        /// do this sometimes when we want to a node's arcs.  There are nodes saved
        /// at the other ends of those arcs however those nodes are just going to
        /// be thrown away at the end of the merge.
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        public virtual void switchNetwork(Network from, Network to)
        {
            switchNetwork(from, to, false);
        }
        public virtual void switchNetwork(Network from, Network to, bool silently)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the selectable values for the n'th input.
        /// This returns a pointer to a constant array of pointers to
        /// constant strings which is NOT to be manipulated by the caller.
        /// The returned array of pointers is NULL terminated.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public String getInputValueOptions(int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return the window associated with this node (if one exists)
        /// </summary>
        /// <returns></returns>
        public virtual DXWindow getDXWindow() { return null; }


        /// <summary>
        /// Get the node title (if the node has a title)
        /// </summary>
        /// <returns></returns>
        public virtual String getTitle() { return null; }


        /// <summary>
        /// Provide a mechanism on behalf of StandIn for getting a small piece of text
        /// for postscript output.  This text will be associated with the standin.  I
        /// chose to stick this into Node rather than virtualizing the postscript
        /// print func which would be the normal C++ way to handle this.  It's just that
        /// postscript printing is so complicated and so few people want to learn it that
        /// the benefit of making it virtual seems small.   I originally put this here
        /// on behalf of Compute so that there is a way to print the expression.
        /// ComputeNode will supply its expression as extra PS text.
        /// </summary>
        /// <returns></returns>
        public virtual String getExtraPSText() { return null; }


        public virtual bool needsFastSort() { return false; }

        public virtual bool printAsJava(StreamWriter sw)
        {
            throw new Exception("Not Yet Implemented");
        }
        public virtual String getJavaNodeName() { return "Node"; }
        public virtual bool hasJavaRepresentation() { return false; }
        public virtual bool printInputAsJava(int input) { return false; }
        public virtual String getJavaInputValueString(int index)
        {
            return getInputValueString(index);
        }

        public virtual bool printAsBean(StreamWriter sw) { return true; }
        public virtual bool printAsBeanInitCall(StreamWriter sw) { return true; }


        public Object getLayoutInformation() { return layout_information; }
        public void setLayoutInformation(Object li) { throw new Exception("Not Yet Implemented"); }


        #endregion 

        #region Public Instances and Properties

        public const int MAX_INPUT_SETS = 21;
        public const int MAX_OUTPUT_SETS = 21;

        public bool IsMarked
        {
            get { return marked; }
        }
        public String NameString
        {
            get { return SymbolManager.theSymbolManager.getSymbolString(this.getNameSymbol()); }
        }
        public String ExecModuleNameString
        {
            get { return definition.NameString; }
        }
        public String Description
        {
            get { return definition.Description; }
        }
        public NodeDefinition Definition
        {
            get { return definition; }
        }
        public int InputCount
        {
            get { return inputParameters.Count; }
        }
        public int OutputCount
        {
            get { return outputParameters.Count; }
        }
        public int InputRepeatCount
        {
            get { return definition.InputRepeatCount; }
        }
        public int OutputRepeatCount
        {
            get { return definition.OutputRepeatCount; }
        }

        public bool HasWriteableCachebility
        {
            get { return definition.HasWriteableCacheability; }
        }
        Cacheability getNodeCacheability() { return this.nodeCacheability; }
        public void setNodeCacheability(Cacheability val)
        {
            if (val != nodeCacheability)
            {
                nodeCacheability = val;
                getNetwork().setDirty();
            }
        }

        public int InstanceNumber { get { return instanceNumber; } }

        #endregion 

        #region IGroupedObject
        protected Dictionary<Symbol, GroupRecord> groups;

        public void addToGroup(String group, Symbol groupID)
        {
            String groupStr = SymbolManager.theSymbolManager.getSymbolString(groupID);
            GroupManager gmgr = getNetwork().getGroupManagers()[groupStr];
            Debug.Assert(gmgr != null);

            if (!gmgr.hasGroup(group))
                gmgr.createGroup(group, getNetwork());

            GroupRecord grec = gmgr.getGroup(group);
            Debug.Assert(grec != null);

            setGroupName(grec, groupID);
        }

        public String getGroupName(Symbol groupID)
        {
            GroupRecord grec = null;
            if (groups == null) return null;

            groups.TryGetValue(groupID, out grec);
            if (grec == null) return null;

            return grec.Name;
        }

        public virtual Network getNetwork() { return network; }

        public virtual bool parseGroupComment(String comment, String filename, int lineno)
        {
            Dictionary<String, GroupManager> groupManagers = getNetwork().getGroupManagers();
            int count = groupManagers.Count;
            bool group_comment = false;
            GroupManager gmgr = null;
            foreach (KeyValuePair<String, GroupManager> kvp in groupManagers)
            {
                gmgr = kvp.Value;
                String mgr_name = " " + gmgr.getManagerName() + " group:";
                if (comment.StartsWith(mgr_name))
                {
                    group_comment = true;
                    break;
                }
            }
            if (!group_comment) return false;
            String group_name = comment.Substring(comment.IndexOf(":") + 1).Trim();
            if (group_name.Length == 0)
                return false;

            addToGroup(group_name, gmgr.getManagerSymbol());
            return true;
        }
        public virtual bool printGroupComment(Stream s)
        {
            throw new Exception("Not Yet Implemented");
        }
        public virtual void setGroupName(GroupRecord groupRec, Symbol groupID)
        {
            GroupRecord grec = null;

            if (groups != null)
                groups.TryGetValue(groupID, out grec);
            else if (groupRec != null)
                groups = new Dictionary<Symbol, GroupRecord>();

            if (grec != null)
            {
                if (groupRec != null)
                    groups[groupID] = groupRec;
                else
                    groups.Remove(groupID);
            }
            else if (groupRec != null)
            {
                groups.Add(groupID, groupRec);
            }

            getNetwork().setDirty();
        }

        protected Dictionary<Symbol, GroupRecord> group;

        #endregion


    }
}
