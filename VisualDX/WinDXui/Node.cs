using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace WinDX.UI
{
    public class Node : IGroupedObject
    {
        public enum NodeParameterStatusChange {
            ParameterValueChanged = 0x100000,
            PatemeterSetValueChanged = 0x000001 | 0x100000,
            ParameterSetValueToDefaulting = 0x000002 | 0x100000,
            ParameterVisibilityChanged = 0x200000,
            ParameterBecomesVisible = 0x000003 | 0x200000,
            ParameterBecomesInvisible = 0x000004 | 0x200000,
            ParameterArkChanged = 0x400000,
            ParameterArkRemoved = 0x000008 | 0x400000,
            ParameterArkAdded = 0x000010 | 0x400000
        };

        public enum NodeStatusChange
        {
            NodeSelected,
            NodeDeselected
        };

        #region Private Instance Variables
        /// <summary>
        /// Used only be the Network for sorting, graph analysis, etc.
        /// See isMarked(), setMarked() and clearMarked().
        /// </summary>
        private bool marked;

        /// <summary>
        /// Should the executive cache the module's state.
        /// </summary>
        private Cacheability nodeCacheability;

        /// <summary>
        /// The symbol for the node label (contained in theSymbolTable)
        /// </summary>
        private Symbol labelSymbol;

        /// <summary>
        /// The instance number, allocated from the definition.
        /// </summary>
        private int instanceNumber;

        /// <summary>
        /// The network this node belongs to
        /// </summary>
        private Network network;

        /// <summary>
        /// Pointer into a table of definitions generated by the MDF file
        /// </summary>
        private NodeDefinition definition;

        /// <summary>
        /// Current values and definitions for inputs and outputs
        /// </summary>
        private List<Parameter> inputParameters;
        private List<Parameter> outputParameters;

        /// <summary>
        /// Pointer to the UI standin for this node.
        /// </summary>
        private StandIn standin;

        /// <summary>
        /// Pointer to the cdb for this node.
        /// </summary>
        private ConfigurationDialog cdb;

        /// <summary>
        /// Upper left-hand corner of standin for this module.
        /// </summary>
        private int vpe_xpos, vpe_ypos;

        /// <summary>
        /// On behalf of automatic graph layout we need to store information
        /// on a per-node basis.  No one outside of the layout class will
        /// ever access this information, but it's natural to keep in
        /// associated with the Node for fast lookup.
        /// </summary>
        private Object layout_information;

        #endregion

        #region Private Methods
        /// <summary>
        /// his dispatches messages to this->execModuleMessageHandler().
        /// Messages are not noticed unless this handler is installed
        /// (in this->updateModuleMessageProtocol() via this->netPrintNode()).
        /// </summary>
        /// <param name="clientData"></param>
        /// <param name="id"></param>
        /// <param name="line"></param>
        private static void ExecModuleMessageHandler(Object clientData, int id, String line)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Let the Configuration dialog box know that the parameter has changed.
        /// Assumes that the node currently has a cdb.
        /// </summary>
        /// <param name="p"></param>
        /// <param name="index"></param>
        private void notifyCDBParameterChanged(Parameter p, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set the index'th parameter value of the parameter list given by io
        /// to the given value  of type t.  if t==DXType::UndefinedType, then
        /// be sure it can be assigned to one of the allowed types in the
        /// ParameterDefinition.  If 'value' is null, then clear the value (and 
        /// handle as a successful setting) and return the default type for the 
        /// given parameter.
        /// We you the Parameter methods to try and help certain values become
        /// the given type (i.e. by adding "'s, {}'s, []'s and so on).
        /// If send is true (the default), the results will be sent to the server
        /// if possible.
        /// If notify is TRUE, then call ioParameterStatusChanged() with one of
        /// Node::ParameterSetValueChanged and Node::ParameterValueChanged.
        /// index is 0 based.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <param name="t"></param>
        /// <param name="send"></param>
        /// <param name="notify"></param>
        /// <returns></returns>
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value)
        {
            return setIOValue(ref io, index, value, DXTypeVals.UndefinedType, true, true);
        }
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value, DXTypeVals t)
        {
            return setIOValue(ref io, index, value, t, true, true);
        }
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value, DXTypeVals t, bool send)
        {
            return setIOValue(ref io, index, value, t, send, true);
        }
        private DXTypeVals setIOValue(ref List<Parameter> io, int index,
            String value, DXTypeVals t, bool send, bool notify)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// This is the same as setIOValue, but it sends the value to the
        /// executive without causing an executive execution in execute on change.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <param name="t"></param>
        /// <returns></returns>
        private DXTypeVals setIOValueQuietly(ref List<Parameter> io, int index,
            String value)
        {
            return setIOValueQuietly(ref io, index, value, DXTypeVals.UndefinedType);
        }
        private DXTypeVals setIOValueQuietly(ref List<Parameter> io, int index,
            String value, DXTypeVals t)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Mark the given parameter as clean.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="dirty"></param>
        private void setIODirty(ref List<Parameter> io, int index, bool dirty)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the index'th parameter in the give list is connected 
        /// (i.e. has an arc) to another parameter. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOConnected(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the default value of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIODefaultValueString(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set/Get the cacheability of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private Cacheability getIOCacheability(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }
        private bool isIOCacheabilityWriteable(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the currently set value of the index'th parameter in the given 
        /// list.  Ignores the defaulting stuff.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIOSetValueString(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the default value of the index'th parameter in the given list.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIODefaulting(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the value of the index'th parameter in the given list
        /// has been set, independent of whether it's defaulting or not.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOSet(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the value of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIOValueString(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the type of the set value of the index'th parameter in the list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private DXTypeVals getIOSetValueType(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the name of the input as specified in the network
        /// (i.e. main_Display_1_in_3)
        /// </summary>
        /// <param name="index"></param>
        /// <param name="input"></param>
        /// <param name="buffer"></param>
        /// <returns></returns>
        private String getNetworkIONameString(int index,
            bool input)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the name of the index'th parameter in the given list. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIONameString(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Get the description of the index'th parameter in the given list.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIODescription(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return a readonly list of strings that represent the types for 
        /// the given parameter.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private String getIOTypeStrings(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return a list of types for the given parameter.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns>A list of types for the given parameter.</returns>
        List<DXType> getIOTypes(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the index'th parameter from the given list has visible tab. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOVisible(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set the index'th parameter from the given list to be visible.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="v"></param>
        private void setIOVisibility(List<Parameter> io, int index, bool v)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set all unconnected, defaulting params to be either visible or not.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="v"></param>
        private void setAllIOVisibility(List<Parameter> io, bool v)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the index'th parameter from the given list is viewable
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIOViewable(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Print 'name = value'  for the index'th parameter in the given list.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        private String ioValueString(List<Parameter> io, int index, String prefix)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the index'th parameter in the given list is required. 
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        private bool isIORequired(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the given parameter list contains parameters which
        /// can be exposed, implying that there are some that are hidden. 
        /// </summary>
        /// <param name="io"></param>
        /// <returns></returns>
        private bool hasExposableIO(List<Parameter> io)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Determine if the given parameter list contains parameters which
        /// can be hidden, implying that there are some that are exposed. 
        /// </summary>
        /// <param name="io"></param>
        /// <returns></returns>
        private bool hasHideableIO(List<Parameter> io)
        {
            throw new Exception("Not Yet Implemented");
        }



        /// <summary>
        /// Return a list of Arks for the given parameter.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public List<Ark> getIOArks(List<Parameter> io, int index)
        {
            throw new Exception("Not Yet Implemented");
        }
        #endregion

        #region Protected Instance Variables

        /// <summary>
        /// Used as a unique identifier for this instance of this Node when  
        /// installing the Module message handler.
        /// </summary>
        protected String moduleMessageId;

        #endregion

        #region Protected Methods

        protected void setInstanceNumber(int inst) { instanceNumber = inst; }
        protected bool appendInput(Parameter p)
        {
            if (inputParameters == null)
                return false;
            inputParameters.Add(p);
            return true;
        }
        protected bool appendOutput(Parameter p)
        {
            if (outputParameters == null)
                return false;
            outputParameters.Add(p);
            return true;
        }

        /// <summary>
        /// Add an Ark to the index'th parameter of parameter list 'io'.
        /// </summary>
        /// <param name="io"></param>
        /// <param name="index"></param>
        /// <param name="a"></param>
        /// <returns></returns>
        protected virtual bool addIOArk(List<Parameter> io, int index, Ark a)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected virtual bool removeIOArk(List<Parameter> io, int index, Ark a)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected bool removeInputArk(int index, Ark a)
        {
            return removeIOArk(inputParameters, index, a);
        }
        protected bool removeOutputArk(int index, Ark a)
        {
            return removeIOArk(outputParameters, index, a);
        }

        /// <summary>
        /// Add/remove a set of repeatable input or output parameters to the
        /// this node.   An error  ocurrs if the parameter list indicated does
        /// not have repeatable parameters.
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        protected virtual bool addRepeats(bool input)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected virtual bool removeRepeats(bool input)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected Parameter getInputParameter(int i)
        {
            return inputParameters[i];
        }
        protected Parameter getOutputParameter(int i)
        {
            return outputParameters[i];
        }

        protected virtual int strcatParameterNameLvalue(String s, Parameter p,
            String prefix, int index)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected int strcatParameterValueString(String s, Parameter p, int index)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Parse either on input or an output comment, setting the value of
        /// the indicated parameter with the value and type found in the comment.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="comment"></param>
        /// <param name="filename"></param>
        /// <param name="lineno"></param>
        /// <returns></returns>
        protected virtual bool parseIOComment(bool input, String comment,
            String filename, int lineno)
        {
            return parseIOComment(input, comment, filename, lineno, false);
        }
        protected virtual bool parseIOComment(bool input, String comment, 
            String filename, int lineno, bool valueOnly)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// These are called when a 'node' comment is found in the .net.
        /// </summary>
        /// <param name="comment"></param>
        /// <param name="filename"></param>
        /// <param name="lineno"></param>
        /// <returns></returns>
        protected bool netParseNodeComment(String comment, String filename,
            int lineno)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// These are called to parse any comments after the 'node', 'input',
        /// 'output' and 'pgrp'  comments in the .net file.
        /// </summary>
        /// <param name="comment"></param>
        /// <param name="filename"></param>
        /// <param name="lineno"></param>
        /// <returns></returns>
        protected virtual bool netParseAuxComment(String comment,
            String filename, int lineno)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Create the invocation of the script language Node call. 
        /// The string that is returned should be deleted by the caller.
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns></returns>
        protected virtual String netNodeString(String prefix)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Create the invocation of any script language that is
        /// to occur at the beginning or end of the containing macro.
        /// The string that is returned should be deleted by the caller.
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns></returns>
        protected virtual String netBeginningOfMacroNodeString(String prefix)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected virtual String netEndOfMacroNodeString(String prefix)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Put a parameter name/value ('name = value;') pair into a string if
        /// the parameter is a value.  They may return NULL if no strings are
        /// to be printed.
        /// </summary>
        /// <param name="i"></param>
        /// <param name="prefix"></param>
        /// <returns></returns>
        protected virtual String inputValueString(int i, String prefix)
        {
            return ioValueString(inputParameters, i, prefix);
        }
        protected virtual String outputValueString(int i, String prefix)
        {
            return ioValueString(outputParameters, i, prefix);
        }
        protected virtual String valueString(String prefix)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Set the index'th i/o parameter to use either the default value 
        /// or the assigned valued. if notify is TRUE then call 
        /// ioParameterStatusChanged() with Node::ParameterSetValueToDefaulting.
        /// If there is a connection to the executive, then send the change.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="input"></param>
        /// <param name="defaulting"></param>
        protected void setIODefaultingStatus(int index, bool input,
            bool defaulting)
        {
            setIODefaultingStatus(index, input, defaulting, true, true);
        }
        protected void setIODefaultingStatus(int index, bool input,
            bool defaulting, bool send)
        {
            setIODefaultingStatus(index, input, defaulting, send, true);
        }
        protected void setIODefaultingStatus(int index, bool input,
            bool defaulting, bool send, bool notify)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Notify anybody that needs to know that a parameter has changed its
        /// value or arcs.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="index"></param>
        /// <param name="status"></param>
        protected virtual void ioParameterStatusChanged(bool input, int index,
            NodeParameterStatusChange status)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// notifyIo is the same as io sort of.  notifyIo adds a check to see
        /// if the network is in the process of going away.  That avoids useless work.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="index"></param>
        /// <param name="status"></param>
        protected void notifyIoParameterStatusChanged(bool input, int index,
            NodeParameterStatusChange status)
        {
            throw new Exception("Not Yet Implemented");
        }


        /// <summary>
        /// Used by netPrintNode() to print the Names of it's input and output 
        /// parameters.  In the case of inputs, if the input is taking output
        /// from another source (i.e it has an arc), then we print the name
        /// of that output instead.
        /// </summary>
        /// <param name="varprefix"></param>
        /// <returns></returns>
        protected virtual String inputParameterNamesString(String varprefix)
        {
            return inputParameterNamesString(varprefix, null);
        }
        protected virtual String inputParameterNamesString(String varprefix,
            String indent)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected virtual String outputParameterNamesString(String prefix)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected bool netPrintCommentHeader(Stream s)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected virtual bool printIOComment(Stream s, bool input, int index)
        {
            return printIOComment(s, input, index, null, false);
        }
        protected virtual bool printIOComment(Stream s, bool input, int index,
            String indent)
        {
            return printIOComment(s, input, index, indent, false);
        }
        protected virtual bool printIOComment(Stream s, bool input, int index,
            String indent, bool valueOnly)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected bool netPrintPgrpComment(Stream s)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected virtual bool netPrintAuxComment(Stream s)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Called when a message is received from the executive after
        /// this->ExecModuleMessageHandler() is registered in 
        /// this->Node::netPrintNode() to receive messages for this node.  
        /// The format of the message coming back is defined by the derived class.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="line"></param>
        protected virtual void execModuleMessageHandler(int id, String line)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Update the state of message handling for a module/UI message.
        /// This is called only when we send a Node's module call to the executive
        /// and the node has a module messaging protocol as defined by
        /// this->hasModuleMessageProtocol().
        /// </summary>
        /// <param name="pif"></param>
        protected virtual void updateModuleMessageProtocol(DXPacketIF pif)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return TRUE/FALSE, indicating whether or not we support a message 
        /// protocol between the executive module that runs for this node and the
        /// UI.  By default Nodes do not have message protocols.
        /// </summary>
        /// <returns></returns>
        protected virtual bool hasModuleMessageProtocol()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Return TRUE/FALSE, indicating whether or not we expect to receive
        /// a message from the UI when our module executes in the executive.
        /// Be default Nodes do not expect messages.
        /// </summary>
        /// <returns></returns>
        protected virtual bool expectingModuleMessage()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Returns a string that is used to register 
        /// this->ExecModuleMessageHandler() when this->hasModuleMessageProtocol() 
        /// return TRUE.  This version, returns an id that is unique to this 
        /// instance of this node.
        ///
        /// IMPORTANT: this must set this->moduleMessageId so that Node::~Node()
        ///		can know the id string. 
        /// </summary>
        /// <returns></returns>
        protected virtual String getModuleMessageIdString()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Do any work that must be done before sending the macro/network
        /// that this node belongs to to the server.
        /// Be default, Nodes do not have any work that needs to be done 
        /// before sending.
        /// </summary>
        protected virtual void prepareToSendNode()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Do any work that must be done before sending the given parameter value 
        /// to the server. 
        /// Be default, Nodes do not have any work that needs to be done 
        /// before sending parameter values.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="p"></param>
        protected virtual void prepareToSendValue(int index, Parameter p)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// See if the given string is a viable label to be used as an identifier.
        /// Also make sure it is not a reserved script language word.
        /// Return TRUE if ok, FALSE otherwise and issue and error message.
        /// </summary>
        /// <param name="label"></param>
        /// <returns></returns>
        protected bool verifyRestrictedLabel(String label)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Print/parse the 'node %s[%d]:' comment.
        /// Not all nodes have cfg info, but it is provided for those that do.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        protected bool cfgPrintNodeLeader(Stream s)
        {
            throw new Exception("Not Yet Implemented");
        }
        protected bool cfgParseNodeLeader(String comment,
            String file, int lineno)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected virtual void setIOCacheability(List<Parameter> io, int index, Cacheability c)
        {
            throw new Exception("Not Yet Implemented");
        }

        #endregion

        #region Public Methods

        public Node(NodeDefinition nd, Network net, int inst)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Generate a new instance number for this node.  We notify the
        /// standIn and mark the network and the node dirty.
        /// The new instance number is returned.
        /// </summary>
        /// <returns></returns>
        public virtual int assignNewInstanceNumber()
        {
            throw new Exception("Not Yet Implemented");
        }


        public void setMarked() { this.marked = true; }
        public void clearMarked() { this.marked = false; }


        public virtual void setDefinition(NodeDefinition nd)
        {
            throw new Exception("Not Yet Implemented");
        }
        public virtual void updateDefinition()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Build a Node's input and output parameter lists based on this
        /// node definition.
        /// </summary>
        /// <returns></returns>
        public bool buildParameterLists()
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Perform any additional initializations that were not performed
        /// in the constrctor.  If this returns TRUE initialization was 
        /// successful, otherwise FALSE.  If FALSE, then it is assumed that
        /// initialize() will issue the error/warning message. 
        /// initialize() is called before the Node is actually added to the
        /// Network.
        /// </summary>
        /// <returns></returns>
        public virtual bool initialize()
        {
            throw new Exception("Not Yet Implemented");
        }


        /// <summary>
        /// initializeAfterNodeMember() is called after initialize() but after the 
        /// Node is actually added to the Network.
        /// </summary>
        public virtual void initializeAfterNetworkMember()
        {
            // no implementation
        }


        public virtual Symbol getNameSymbol()
        {
            return this.definition.NameSymbol;
        }

        public virtual bool setLabelString(String label)
        {
            throw new Exception("Not Yet Implemented");
        }
        public virtual String getLabelString()
        {
            throw new Exception("Not Yet Implemented");
        }

        public void setVpePosition(int x, int y)
        {
            throw new Exception("Not Yet Implemented");
        }

        /// <summary>
        /// Add/remove a set of input our output parameters to the give model.
        /// </summary>
        /// <returns></returns>
        public bool addInputRepeats() { return addRepeats(true); }
        public bool removeInputRepeats() { return removeRepeats(true); }
        public bool addOutputRepeats() { return addRepeats(false); }
        public bool removeOutputRepeats() { return removeRepeats(false); }


        public bool hasExposableInput()
        {
            return hasExposableIO(inputParameters);
        }
        public bool hasExposableOutput()
        {
            return hasExposableIO(outputParameters);
        }
        public bool hasHideableInput()
        {
            return hasHideableIO(inputParameters);
        }
        public bool hasHideableOutput()
        {
            return hasHideableIO(outputParameters);
        }

        public bool hasRemovableInput()
        {
            throw new Exception("Not Yet Implemented");
        }
        public bool hasRemovableOutput()
        {
            throw new Exception("Not Yet Implemented");
        }
        public bool isInputRepeatable()
        {
            throw new Exception("Not Yet Implemented");
        }
        public bool isOutputRepeatable()
        {
            throw new Exception("Not Yet Implemented");
        }

        // Manage inputs
        public bool addInputArk(Ark a, int index)
        {
            return addIOArk(inputParameters, index, a);
        }
        public bool addOutputArk(Ark a, int index)
        {
            return addIOArk(outputParameters, index, a);
        }

        public List<Ark> getInputArks(int index)
        {
            return getIOArks(inputParameters, index);
        }

        public List<Ark> getOutputArks(int index)
        {
            return getIOArks(outputParameters, index);
        }

        public virtual bool deleteArk(Ark a)
        {
            throw new Exception("Not Yet Implemented");
        }


        public String getInputValueString(int index)
        {
            return getIOValueString(inputParameters, index);
        }
        public String getOutputValueString(int index)
        {
            return getIOValueString(outputParameters, index);
        }
        public DXTypeVals getInputSetValueType(int index)
        {
            return getIOSetValueType(inputParameters, index);
        }
        public DXTypeVals getOutputSetValueType(int index)
        {
            return getIOSetValueType(outputParameters, index);
        }


        public String getInputNameString(int index)
        {
            return getIONameString(inputParameters, index);
        }
        public String getOutputNameString(int index)
        {
            return getIONameString(outputParameters, index);
        }

        /// <summary>
        /// Get the name of the input as specified in the network
        /// (i.e. main_Display_1_in_3)
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public String getNetworkInputNameString(int index)
        {
            return getNetworkIONameString(index, true);
        }
        public String getNetworkOutputNameString(int index)
        {
            return getNetworkIONameString(index, false);
        }

        public String getInputTypeString(int index)
        {
            return getIOTypeStrings(inputParameters, index);
        }
        public String getOutputTypeStrings(int index)
        {
            return getIOTypeStrings(outputParameters, index);
        }


        public List<DXType> getInputTypes(int index)
        {
            return getIOTypes(inputParameters, index);
        }
        public List<DXType> getOutputTypes(int index)
        {
            return getIOTypes(outputParameters, index);
        }


        public String getInputDescription(int index)
        {
            return getIODescription(inputParameters, index);
        }
        public String getOutputDescription(int index)
        {
            return getIODescription(outputParameters, index);
        }

        public String getInputDefaultValueString(int index)
        {
            return getIODefaultValueString(inputParameters, index);
        }

        public String getInputSetValueString(int index)
        {
            return getIOSetValueString(inputParameters, index);
        }

        public bool isInputRequired(int index)
        {
            return isIORequired(inputParameters, index);
        }
        public bool isOutputRequired(int index)
        {
            return isIORequired(outputParameters, index);
        }

        public bool isInputConnected(int index)
        {
            return isIOConnected(inputParameters, index);
        }
        public bool isOutputConnected(int index)
        {
            return isIOConnected(outputParameters, index);
        }
        public bool isParameterConnected(int index, bool input)
        {
            return (input ? isIOConnected(inputParameters, index) :
                isIOConnected(outputParameters, index));
        }

        public void setInputVisibility(int index, bool v)
        {
            setIOVisibility(inputParameters, index, v);
        }
        public void setOutputVisibility(int index, bool v)
        {
            setIOVisibility(outputParameters, index, v);
        }

        public void setAllInputsVisibility(bool v)
        {
            setAllIOVisibility(inputParameters, v);
        }
        public void setAllOutputsVisibility(bool v)
        {
            setAllIOVisibility(outputParameters, v);
        }

        public void clearInputDirty(int index)
        {
            setIODirty(ref inputParameters, index, false);
        }
        public void setInputDirty(int index)
        {
            setIODirty(ref inputParameters, index, true);
        }
        public void clearOutputDirty(int index)
        {
            setIODirty(ref outputParameters, index, false);
        }
        public void setOutputDirty(int index)
        {
            setIODirty(ref outputParameters, index, true);
        }

        public bool isInputVisible(int index)
        { return isIOVisible(inputParameters, index); }
        public bool isOutputVisible(int index)
        { return isIOVisible(outputParameters, index); }
        public bool isParameterVisible(int index, bool input)
        {
            return (input ? isInputVisible(index) : isOutputVisible(index));
        }

        public bool isInputViewable(int index)
        {
            return isIOViewable(inputParameters, index);
        }
        public bool isOutputViewable(int index)
        {
            return isIOViewable(outputParameters, index);
        }
        public bool isParameterViewable(int index, bool input)
        {
            return (input ? isInputViewable(index) : isOutputViewable(index));
        }

        public Cacheability getOutputCacheability(int index)
        {
            return getIOCacheability(outputParameters, index);
        }
        public void setOutputCacheability(int index, Cacheability c)
        {
            setIOCacheability(outputParameters, index, c);
        }
        public bool isOutputCacheabilityWriteable(int index)
        {
            return isIOCacheabilityWriteable(outputParameters, index);
        }

        public bool isInputDefaulting(int index)
        { return isIODefaulting(inputParameters, index); }

        public bool isInputSet(int index)
        { return isIOSet(inputParameters, index); }


        // Match output_index of this node tho input_index of n. Returns true
        // if they can connect.
        public virtual bool typeMatchOutputToInput(int output_index, Node n, int input_index)
        {
            throw new Exception("Not Yet Implemented");
        }

        // Set the stored value.
        // If the parameter is not defaulting, this is
        // the same as setValue, but if it is defaulting, then we set the
        // value but leave the parameter clean and defaulting and ignore send.
        public virtual DXTypeVals setInputSetValue(int index, String value)
        {
            return setInputSetValue(index, value, DXTypeVals.UndefinedType, true);
        }
        public virtual DXTypeVals setInputSetValue(int index, String value, DXTypeVals type)
        {
            return setInputSetValue(index, value, type, true);
        }
        public virtual DXTypeVals setInputSetValue(int index, String value, DXTypeVals type,
            bool send)
        {
            throw new Exception("Not Yet Implemented");
        }

        public virtual DXTypeVals setInputValue(int index, String value)
        {
            return setInputValue(index, value, DXTypeVals.UndefinedType, true);
        }
        public virtual DXTypeVals setInputValue(int index, String value, DXTypeVals type)
        {
            return setInputValue(index, value, type, true);
        }
        public virtual DXTypeVals setInputValue(int index, String value, DXTypeVals type,
            bool send)
        {
            return setIOValue(ref inputParameters, index, value, type, send);
        }



        #endregion 

        #region Public Instances and Properties

        public bool IsMarked
        {
            get { return marked; }
        }
        public String NameString
        {
            get { return SymbolManager.theSymbolManager.getSymbolString(this.getNameSymbol()); }
        }
        public String ExecModuleNameString
        {
            get { return definition.NameString; }
        }
        public String Description
        {
            get { return definition.Description; }
        }
        public NodeDefinition Definition
        {
            get { return definition; }
        }
        public int InputCount
        {
            get { return inputParameters.Count; }
        }
        public int OutputCount
        {
            get { return outputParameters.Count; }
        }
        public int InputRepeatCount
        {
            get { return definition.InputRepeatCount; }
        }
        public int OutputRepeatCount
        {
            get { return definition.OutputRepeatCount; }
        }

        public bool HasWriteableCachebility
        {
            get { return definition.HasWriteableCacheability; }
        }

        #endregion 

        #region IGroupedObject

        public void addToGroup(String group, Symbol groupID)
        {
            throw new Exception("Not Yet Implemented");
        }
        public String getGroupName(Symbol groupID)
        {
            throw new Exception("Not Yet Implemented");
        }
        public Network getNetwork() { return network; }

        public bool parseGroupComment(String comment, String filename, int lineno)
        {
            throw new Exception("Not Yet Implemented");
        }
        public bool printGroupComment(Stream s)
        {
            throw new Exception("Not Yet Implemented");
        }
        public void setGroupName(GroupRecord gr, Symbol groupID)
        {
            throw new Exception("Not Yet Implemented");
        }

        protected Dictionary<Symbol, GroupRecord> group;

        #endregion


    }
}
