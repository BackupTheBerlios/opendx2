<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3//EN">
<HTML><HEAD>
<TITLE>IBM Visualization Data Explorer User&#39;s Reference</TITLE>

<META HTTP-EQUIV="abstract" CONTENT="IBM Visualization Data Explorer User&#39;s
Reference">
<META HTTP-EQUIV="contact" CONTENT="IBM Visualization Data Explorer
(ibmdx@watson.ibm.com)">
<META HTTP-EQUIV="owner" CONTENT="IBM Visualization Data Explorer
(ibmdx@watson.ibm.com)">
<META HTTP-EQUIV="updated" CONTENT="Tue, 16 Sep 1997 ">
<META HTTP-EQUIV="review" CONTENT="Fri, 14 Aug 1998 ">

<META HTTP-EQUIV="keywords" CONTENT="GRAPHICS VISUALIZATION VISUAL PROGRAM DATA
MINING">
</HEAD><BODY BGCOLOR="#FFFFFF">

<A NAME="Top_Of_Page"></A>
<H1>IBM Visualization Data Explorer User&#39;s Reference</H1>
<B>&#91; <A HREF="#Bot_Of_Page">Bottom of Page</A> &#124; <A
HREF="refgu047.htm">Previous Page</A> &#124; <A HREF="refgu049.htm">Next
Page</A> &#124; <A HREF="../refguide.htm#ToC">Table of Contents</A> &#124; <A
HREF="refgu009.htm#PToC4">Partial Table of Contents</A> &#124; <A
HREF="refgu175.htm#HDRINDEX_START">Index</A> &#93;</B><HR><P>
<H3><A NAME="HDRDISPLAY" HREF="refgu009.htm#PToC_70">Display</A></H3>
<A NAME="IDX448"></A>
<A NAME="IDX449"></A>
<P><STRONG>Category</STRONG>
<P>
<A HREF="refgu008.htm#HDRCATREN">Rendering</A>
<P><STRONG>Function</STRONG>
<P>
Displays an image or renders a scene and displays an image.
<P><STRONG>Syntax</STRONG>
<PRE>

<TT><STRONG>where</STRONG></TT> = Display(<STRONG>object, camera, where, throttle</STRONG>);

</PRE>
<P><STRONG>Inputs</STRONG>
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Default
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT><STRONG>object</STRONG></TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">object
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">none
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">object to render or image to
display
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT><STRONG>camera</STRONG></TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">camera
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">no default
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">camera if rendering is required
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT><STRONG>where</STRONG></TT>

</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">window or string

</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">the user&#39;s terminal
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">host and window for display
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT><STRONG>throttle</STRONG></TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">scalar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">0
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">minimum time between image frames
(in seconds)
</TD></TR></TABLE>

<P><STRONG>Outputs</STRONG>
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT><STRONG>where</STRONG></TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">window
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">window identifier for Display
window
</TD></TR></TABLE>

<P><STRONG>Functional Details</STRONG>
<P>
<TABLE CELLPADDING="3">
<TR VALIGN="TOP"><TD><P><B><TT><STRONG>object</STRONG></TT>
</B></TD><TD><P>is the object to be displayed or to be rendered and displayed.
</TD></TR><TR VALIGN="TOP"><TD><P><B><TT><STRONG>camera</STRONG></TT>
</B></TD><TD><P>is the camera to be used to render
<TT><STRONG>object</STRONG></TT>.
If <TT><STRONG>camera</STRONG></TT> is not specified, the system assumes that
<TT><STRONG>object</STRONG></TT> is an image to be displayed (e.g., the
output of the Render module).
<P><B>Note: </B>A transformed camera cannot be used for this parameter.
</TD></TR><TR VALIGN="TOP"><TD><P><B><TT><STRONG>where</STRONG></TT>
</B></TD><TD><P>specifies the host and window for displaying
the image.
On a workstation, the format of the parameter string is:
<BR>
<TT><STRONG>X</STRONG></TT>, <VAR>display, window</VAR><BR>
where <TT><STRONG>X</STRONG></TT> refers to the X Window System;
<VAR>display</VAR> is an X server name (e.g.,
host&#58;0); and <VAR>window</VAR> is a
window name (and must not begin with
two #-characters).
As a rule, it is not necessary to set this parameter.
But when it is set, the resulting Image window is not controlled by
the user interface (e.g., it has no menu options).
The function of this parameter is to specify another workstation on
which to display an image (e.g., by setting it to
"<I>X,</I><TT>workstationname</TT><I>:0,</I>
<TT>message</TT>").
Using the Image tool, you can display the same image to another
workstation simply by connecting the module&#39;s two outputs
to the two inputs of Display and setting
<TT><STRONG>where</STRONG></TT>.
<P>
If you are using SuperviseState or SuperviseWindow to control user
interactions in the Display window, then <TT><STRONG>where</STRONG></TT>
should be set with the <TT><STRONG>where</STRONG></TT> output of
SuperviseWindow.
<P><B>Note: </B>

If you are using the <TT><STRONG>where</STRONG></TT> parameter,

it is important to set its value <I>before</I> the first execution
of Display.
</TD></TR><TR VALIGN="TOP"><TD><P><B><TT><STRONG>throttle</STRONG></TT>
</B></TD><TD><P>specifies a minimum interval between successive image displays.
The default is 0 (no delay).

</TD></TR><TR VALIGN="TOP"><TD><P><B><TT><STRONG>where</STRONG></TT>
</B></TD><TD><P>The output can be used, for example, by ReadImageWindow to
retrieve
the pixels of an image after Display has run.

</TD></TR></TABLE>
<P><B>Notes: </B><OL>
<P><LI>In the user interface, you must use the Image tool rather than
Display if you want to use many of the interactive image-manipulation
functions provided by Data Explorer.
For more information,
see <A HREF="usrgu040.htm#HDRCHAV">"Controlling the Image: View Control..."</A>
in <I>IBM Visualization Data Explorer User&#39;s Guide</I>.

However, see <A HREF="refgu153.htm#HDRSUPWIND">SuperviseWindow</A> and <A
HREF="refgu152.htm#HDRSUPSTAT">SuperviseState</A> for a
discussion of how to create your own interaction modes when using the
Display window.

<P><LI>The Display module can render surfaces, volumes, and arbitrary
combinations of surfaces and volumes.
(However, the current volume-rendering algorithm does not support
coincident or perspective volumes.)
To render an object, that object must contain a "colors"
component.
Many modules add a default color.
In addition, volume rendering (e.g., of cubes, as opposed to lines)
requires an "opacities" component.
all surfaces, the lack of an "opacities" component implies an
opaque surface.
<P><LI>Choosing appropriate color and opacity maps for volume rendering
can be difficult.
The AutoColor,

AutoGrayScale,

and Color modules use heuristics to generate good values;
as a rule of thumb, the opacity should be &approx.0.7/T, and the
color value &approx.1.4/T (where T is the thickness of the
object in user units).

See also <A HREF="#HDRCVOLRND">"Coloring Objects for Volume Rendering"</A>.

</OL>

<P>
<H5><A NAME="Header_71">Changing the Resolution of an Image</A></H5>
<P>If you are using Display without a camera to simply display an image,
you can increase or decrease the resolution of the image by using Refine
or Reduce, respectively, on the image before passing it to Display
(see
<A HREF="refgu114.htm#HDRREFINE">Refine</A>
and
<A HREF="refgu113.htm#HDRREDUCE">Reduce</A>).
<P>
<H5><A NAME="Header_72">Pasting Images Together</A></H5>
<P>The Arrange module can be used before Display to lay out images side
by side, or one above the other (see
<A HREF="refgu012.htm#HDRARRANGE">Arrange</A>).


<P>
<H5><A NAME="HDRDLACOOP">Delayed Colors and Opacities (Color and Opacity Lookup
Tables)</A></H5>
Delayed colors are a way of compactly storing color and opacity
information. By default, whenever you use one of the coloring modules
(AutoColor, AutoGrayScale, Color), the colors and opacities are stored
one-per-data value as a floating point RGB 3-vector or floating point
value, respectively, ranging from 0 to 1. However, if you have unsigned
byte data, then it is much more efficient to use "delayed colors"
and "delayed opacities". When you use delayed colors or opacities,
the "colors" or "opacities" component is simply a copy of
(actually a reference to) the "data" component. When rendering
occurs, these components are interpreted as indices with which to look
up a color or opacity value in a table.
<P>
If you specify the <TT><STRONG>delayed</STRONG></TT> parameter as 1 to any of
the coloring modules, they will automatically perform this "copy"
of the "data" component, and will attach a "color map" or
"opacity map" component which contains 256 RGB colors, or 256
opacities. If you already have a color or opacity map, either imported
or created using the Colormap Editor, and wish to use delayed colors or
delayed opacities, you can pass your color map or opacity map to the
Color module as the <TT><STRONG>color</STRONG></TT> or
<TT><STRONG>opacity</STRONG></TT> parameter, and set the
<TT><STRONG>delayed</STRONG></TT> parameter to Color as 1.
<P>
The structure of a color map or opacity map is described in
<A HREF="refgu033.htm#HDRCOLOR">Color</A>. The Colormap Editor produces as its
two outputs
well-formed color maps and opacity maps. Alternatively, if you already
have a simple list of 3-vectors or list of scalar values, and want to
create a color map or opacity map, you can do this using Construct. The
first parameter to Construct should be &#91;0&#93;, the second should
be &#91;1&#93;, and the third should be 256. This will create a
"positions" component with positions from 0 to 255. The last
parameter to Construct should be your list of 256 colors or opacities.
<P>
If you are reading a stored image using ReadImage, and the image is
stored with a colormap, you can specify that the image should be
stored internally in Data Explorer with delayed colors by using the
<TT><STRONG>delayed</STRONG></TT> parameter to ReadImage.
<P>
You can also convert an image (or object) to a delayed colors version
by using QuantizeImage.

<P>
<H5><A NAME="HDRUDCMPS">Using Direct Color Maps</A></H5>
<A NAME="IDX450"></A>
<A NAME="IDX451"></A>
<A NAME="IDX452"></A>
<P>
If you are using delayed colors

(see <A HREF="#HDRDLACOOP">"Delayed Colors and Opacities (Color and Opacity
Lookup Tables)"</A> and <A HREF="refgu110.htm#HDRREADIMA">ReadImage</A>)

and displaying images directly (i.e. you are not
providing a camera), Display will use the provided color
map directly instead of dithering the image.
(Depending on your X server, you may need to use the mouse to select
the Image or Display window in order for the correct color to
appear.)
If you do not want Display to use the color map directly, use the
Options module to set a "direct color map" attribute
with a value of 0 (zero).

<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Attribute Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">Value
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">direct color map
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">0 or 1
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">whether or not to use a direct
color map
</TD></TR></TABLE>

<P>
<H5><A NAME="HDRUDFCMPS">Using Default Color Maps</A></H5>
<A NAME="IDX453"></A>
<A NAME="IDX454"></A>
<A NAME="IDX455"></A>
<P>
When displaying non-delayed color images in 8-bit windows, Display assumes
that it can specify 225 individual colors.
If this number is not currently available in the shared color map,
Display will find the best approximations available.
However, this may lead to a visible degradation of image quality.
Display may instead use a private color map.
This decision is based on the worst-case approximation that it must
use with the default color map.
If this approximation exceeds a threshold, a private color map will be
used.
The approximation quality is measured as Euclidean distance between the
desired color and the best approximation for that color, in an RGB
unit cube.
<P>
An environment variable, DX8BITCMAP, sets the level at which the change
to using a private color map is made.
The value of DX8BITCMAP should be a number between 0 (zero) and 1
(one), and it represents the Euclidean distance in RGB color
space, normalized to 1, for the maximum allowed
discrepancy.
If you set DX8BITCMAP to 1, then a private color map will never be used.
On the other hand, if you set DX8BITCMAP to &#45;1, then a private
color map will always be used.
The default is 0.1.

See also the <TT>-8bitcmap</TT> command line option for Data Explorer
in <A HREF="usrgu071.htm#TBLCLOPTS">Table 5</A> in <I>IBM Visualization Data
Explorer User&#39;s Guide</I>.

<P>
<H5><A NAME="HDRGAMMACO">Gamma Correction</A></H5>
<A NAME="IDX456"></A>
<P>
Displayed images generated by Display or Image are
gamma corrected.
Gamma correction adjusts for the fact that for many display devices a
doubling of the digital value of an image&#39;s brightness does not
necessarily produce a doubling of the actual screen brightness.
Thus, before displaying to the screen, the pixel values are adjusted
non-linearly to produce a more accurate appearance.
<P>
The environment variables DXGAMMA&#95;8BIT, DXGAMMA&#95;12BIT, and
DXGAMMA&#95;24BIT are used to specify values for gamma of
8-, 12-, and 24-bit windows, respectively.
If the appropriate DXGAMMA&#95;<I>n</I>BIT environment variable is not
set, the value of the environment variable DXGAMMA will be used if
one is defined.
Otherwise, the module uses the system default, which depends on the
machine architecture and window depth.
This default is always 2 (two) except for 8-bit sgi windows, for which
it is 1 (one).
Note that the default depends on the machine on which the software
renderer is running, not on the machine that displays the image.

<P>
<H5><A NAME="Header_77">Obtaining a WYSIWYG image of a higher
resolution</A></H5>
<P>If you wish to render a displayed image at a higher resolution (for
example to write to an output file), you can usually simply use Render
on the same object as <TT><STRONG>object</STRONG></TT>, with a new camera
(see <A HREF="refgu015.htm#HDRAUTOCAM">AutoCamera</A> or <A
HREF="refgu021.htm#HDRCAMERA">Camera</A>).
However, if <TT><STRONG>object</STRONG></TT> contains screen objects (captions
and color bars), the new image will not be WYSIWYG (What You See Is What
You Get), with respect to the displayed image, because the sizes of
captions and color bars are specified in pixels rather than in
screen-relative units. The ScaleScreen module (see
<A HREF="refgu130.htm#HDRSCALSCR">ScaleScreen</A>) allows you to modify the size
of screen objects
before rendering.

<P>
<H5><A NAME="HDRIMGCACH">Image Caching</A></H5>
<A NAME="IDX457"></A>
<P>
When given a <TT><STRONG>camera</STRONG></TT> input, the Display module
(or Image tool) caches rendered images by default.
The result is faster redisplay if the same object and camera are
later passed to the module.
<P>
To turn off this automatic caching, use the Options module to attach a
"cache" attribute (set to 0) to <TT><STRONG>object</STRONG></TT>.
<P>
It is important to remember that this caching is separate from the
caching of module outputs, which is controlled by the
<TT>-cache</TT> command-line option to
<TT>dx</TT>.
<P>
<H5><A NAME="HDRCHRNDPR">Changing Rendering Properties</A></H5>
<A NAME="IDX458"></A>
<A NAME="IDX459"></A>
<A NAME="IDX460"></A>
<P>
You can change the rendering properties of an object by using the
Options module.
The following table lists the shading attributes that can be set by
the Options module for interpretation by the Display tool.
(See the section on surface shading in <I>IBM Visualization Data Explorer
Programmer&#39;s Reference</I> for more information.)
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">Attribute
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">Default
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%"><TT>&quot;ambient&quot;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">scalar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">1
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">coefficient of ambient light
<I>k<SUB>a</SUB></I>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%"><TT>&quot;diffuse&quot;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">scalar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">.7
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">coefficient of diffuse reflection
<I>k<SUB>d</SUB></I>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%"><TT>&quot;specular&quot;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">scalar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">.5
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">coefficient of specular
reflection <I>k<SUB>s</SUB></I>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%"><TT>&quot;shininess&quot;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">integer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="19%">10
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">exponent of specular reflection
<I>sp</I>
</TD></TR></TABLE>
As a rule of thumb, except for purposes of special effects,
<I>k<SUB>a</SUB></I> should be <I>1</I>
and <I>k<SUB>d</SUB> &#43; k<SUB>s</SUB></I> should be about 1.
The larger <I>k<SUB>s</SUB></I>,
the brighter the highlight, and the larger
<I>e</I>, the sharper the highlight.

The Shade module provides a shortcut for setting rendering properties.

<P>
The attributes listed above apply to both the front and back of an
object.
In addition, for each attribute "<I>x</I>" there is also a
"front <I>x</I>" and a "back <I>x</I>" attribute
that applies only to the front and back of the surface,
respectively.
So, for example, to disable specular reflections from the back surfaces
of an object, use the Options module to set the "back specular"
attribute of the object to 0.
<P>
The determination of which faces are "front" and which are
"back" depends on the way in which the "connections"
component of the faces is defined.
"Front colors" applies to clockwise faces, and "back colors"
applies to counterclockwise faces.

<P>
<H5><A NAME="HDRCVOLRND">Coloring Objects for Volume Rendering</A></H5>
<P>
The volume renderer interprets colors and opacities as values per unit
distance.
Thus the amount of color and degree of attenuation seen in an image
object is determined in part by the extent of the object&#39;s
volume.
The Color, AutoColor, and AutoGrayScale
modules attach "color multiplier" and "opacity
multiplier" attributes to the object so that colors and
opacities will be appropriate to the volume, while
maintaining "color" and "opacity"
components that range from 0 to 1 (so that
objects derived from the colored volume,
such as glyphs and boundaries, are
colored correctly).
See <A HREF="progu077.htm#HDRRENDMDL">"Rendering Model"</A> in <I>IBM
Visualization Data Explorer Programmer&#39;s Reference</I>.
<P>
These attributes adjust the colors and opacities to values that should
be "appropriate" for the object being colored.
However, if the simple heuristics used by these modules to compute the
attribute values are not producing the desired colors and opacities, you
have two alternatives.
<UL COMPACT>
<LI>One is to modify the result by changing the multiplier values of the
color and opacity attributes:
<OL COMPACT>
<LI>extract the "color multiplier" and "opacity multiplier"
with the Attribute module;
<LI>modify them with the Compute module; and
<LI>replace them in the object with the Options module.
</OL>
<LI>A second is to multiply the values in the "color" or
"opacities" component:
<OL COMPACT>
<LI>mark the component ("colors" or "opacities") with the
Mark module;
<LI>modify the values with the Compute module; and
<LI>"unmark" them with the Unmark module to return them to the
appropriate component.
</OL>
</UL>
<P>
Only the first of these methods should be used for "delayed"
colors.
<P>
Finally, if you color a group of volumes and the resulting image is
black, the reason is that the current renderer does not
support coincident volumes.
<P>
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Attribute
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">color multiplier
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">scalar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Multiplies values in the "color"
component
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">opacity multiplier
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">scalar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Multiplies values in the
"opacity" component
</TD></TR></TABLE>


<P>
<H5><A NAME="HDRSHADING">Shading</A></H5>
<P>Objects are shaded when rendered only if a "normals" component
is present. Many modules (e.g. Isosurface) automatically add
"normals", but the FaceNormals, Normals, and Shade modules can also
be used to add normals.  Even if an object has "normals", shading
can be disabled by adding a <TT><STRONG>shade</STRONG></TT> with a value of 0
(the Shade module can do this).
<P>
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Attribute Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">Values
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">shade
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">0 or 1
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">used to specify whether or not to
shade when normals are present
</TD></TR></TABLE>


<P>
<H5><A NAME="HDROBJFUZZ">Object fuzz</A></H5>
<P>
<I>Object fuzz</I> is a method of resolving conflicts between
objects at the same distance from the camera.  For example, it may be
desirable to define a set of lines coincident with a plane.  Normally it
will be unclear which object is to be displayed in front. In addition,
single-pixel lines are inherently inaccurate (i.e. they deviate from the
actual geometric line) by as much as one-half pixel; when displayed
against a sloping surface, this <I>x</I> or <I>y</I> inaccuracy
is equivalent to a <I>z</I> inaccuracy related to the slope of the
surface. The "fuzz" attribute specifies a <I>z</I> value that
will be added to the object before it is compared with other objects in
the scene, thus resolving this problem. The fuzz value is specified in
pixels. For example, a fuzz value of one pixel can compensate for the
described half-pixel inaccuracy when the line is displayed against a
surface with a slope of two.
<P>
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Attribute
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">fuzz
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">scalar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">object fuzz
</TD></TR></TABLE>
<P>
To add fuzz to an object, pass the object through the Options module,
specifying the attribute as <TT><STRONG>fuzz</STRONG></TT> and the value of
the attribute as the number of pixels (typically a small integer).


<P>
<H5><A NAME="HDRANTIALI">Anti-aliasing and Multiple Pixel Width Lines</A></H5>
<P>Hardware rendered images can be made to anti-alias lines, or draw
lines as multiple pixels wide. Note that these options are <I>not</I>
available in software rendering. To specify anti-aliasing of lines, use
the Options module to set an attribute on the object passed to Display of
<TT><STRONG>antialias</STRONG></TT> with the value of "lines". To specify
multiple pixel width lines, use the Options module to set an attribute
of <TT><STRONG>line width</STRONG></TT> with a value of the number of pixels
wide you want the line to be.
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Attribute
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Values
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">antialias
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">"lines"
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">causes lines to be anti-aliased
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">line width
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">n
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">causes lines to be drawn with a
width of n pixels
</TD></TR></TABLE>

<P>
<H5><A NAME="HDRHARDREN">Rendering Approximations</A></H5>
<A NAME="IDX461"></A>
<P>
Data Explorer provides access to the hardware accelerators on the workstation,
in addition to the default software rendering techniques.
The hardware enhancements are available only on workstations that are
equipped with 3-D graphic adapters.
On systems without such adapters, only the software rendering options
are available.
This enhancement is intended to provide increased interactivity,
especially in operations that involve only the rendering
process.
<P>
Data Explorer can also provide accelerated rendering by approximating the
rendering using points, lines, and opaque surfaces.
Such geometric elements are often sufficient to approximate the
appearance of the desired image, and thus are useful for
preliminary visualizations of the data.
<P>
The approximations fall into three main categories: bounding box, dots,
and wireframe.
Wireframe is available only as a hardware rendering technique.
<P>
If you are using the graphical user interface and the Image tool,
you can access the rendering options by using the
<TT><STRONG>Rendering Options</STRONG></TT> option on
the <TT><STRONG>Options</STRONG></TT> pull-down menu
in the Image window.
This option invokes a dialog box that allows you to set the rendering
approximations for continuous and one-time execution.
(For more information, see
<A HREF="usrgu040.htm#HDRGLOPT">"Rendering Options..."</A> in <I>IBM
Visualization Data Explorer User&#39;s Guide</I>.)
<P>
If you are not using the Image tool, then you must use the Options
module to set various attributes that control the rendering
approximations.
The following table lists the attributes that control rendering
approximations, together with the permissible values for
each attribute.
<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Attribute Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">Values
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">&quot;rendering mode&quot;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">&quot;software&quot;
<BR>
"hardware"
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">use software rendering
<BR>
use hardware rendering
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">&quot;rendering approximation&quot;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">&quot;none&quot;
"box"
"dots"
"wireframe"
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">complete rendering object
<BR>
bounding box only
<BR>
dot approximation to object
<BR>
wireframe approximation to object
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">&quot;render every&quot;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="22%"><I>n</I>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">render every <I>n</I>th primitive
<BR>
render everything (default)
</TD></TR></TABLE>
<P><B>Note: </B>If you do not pass a camera to Display (i.e., if
<TT><STRONG>object</STRONG></TT> is already an image),
Display will always use software to display
the image, regardless of the setting of
any rendering options using the
Options tool.
<P>
<H5><A NAME="HDRHARDSOF">Differences between Hardware and Software
Rendering</A></H5>
<A NAME="IDX462"></A>
<A NAME="IDX463"></A>
<A NAME="IDX464"></A>
<A NAME="IDX465"></A>
<OL>
<P><LI>For hardware rendering, when specifying "dots" for "rendering
approximation," lines are drawn in their entirety, whereas for
software rendering only the line end points are drawn.
The "render every" and "wire" approximations are available
only with hardware rendering.
When the "box" approximation is specified, hardware rendering will
show the bounding box of each field in the rendered object, while
software rendering will show only the bounding box of the
entire object.
<P><LI>Some graphics adapters do not support clipping.
On such adapters, "ClipBox" and "ClipPlane" have
no effect.
<P><LI>For some hardware platforms, surfaces specified with opacities are
rendered by the hardware as screen-door surfaces (i.e., every
other pixel is drawn, letting the background
show through).
This allows only one level of opacity and completely obscures a
semi-opaque surface that is behind another semi-opaque
surface.
The transparency effect is hardware dependent, and can produce a
completely opaque or completely transparent appearance.

True transparency is supported for OpenGL platforms.

<P><LI>The image displayed by the hardware rendering can be different
from the image produced by the software rendering.
This is a result of several differences in rendering techniques.
The hardware rendering does not provide gamma correction, causing
images to be slightly darker.
Normals are not reversed when viewing the "inside" of a surface,
with the result that lighting effects are much dimmer on the
"inside" of a surface.
Attributes applied to the "inside" of a surface (e.g.,
"back colors") are ignored.
<P><LI>When using hardware rendering, the <TT><STRONG>where</STRONG></TT>
parameter to Display cannot specify a host other than the one
on which the Display module is running.
However, it can specify a different display attached to the
same host.
<P><LI>The hardware renderer does not duplicate the "dense emitter"
model used by the software renderer for rendering volumes.
Only the data values at the boundary of the volume are rendered,
producing the appearance of a transparent boundary of
the volume.
<P><LI>For hardware rendering, a wireframe rendering approximation is not
intended to produce the same visual results as
ShowConnections.
<P><LI>Hardware rendering handles colors between 0.0 and 1.0.
If colors are outside this range, each color channel is independently
clamped, before lighting is applied.
In software rendering, clamping is done after lighting is applied.
<P><LI>Hardware rendering does not support view angles of less than 0.001
degree.

<P><LI>Anti-aliasing and multiple pixels width lines is only available
in hardware rendering.

</OL>
<P>
<H5><A NAME="HDRTEXTMAP">Texture Mapping</A></H5>
<A NAME="IDX466"></A>
<A NAME="IDX467"></A>
<P>
If the machine on which Data Explorer is running supports OpenGL or GL, then
texture mapping is available using hardware rendering.
Texture mapping is the process of mapping an image (a field with
2-dimensional positions, quad connections, and colors) onto a
geometry field with 2-dimensional connections and,
typically, 3-dimensional positions (e.g., a color
image mapped onto a rubbersheeted height
field).
The advantage of texture mapping over the use of Map, for example, is
that the resulting image may have much greater resolution than the
height map.
<P>
The geometry field must have 2-D connections (triangles or quads) and
must also have a component, with the name "uv," that is
dependent on positions and provides the mapping between the
image and the positions of the
geometry field.
This component consists of 2-vectors.
The origin of the image will be mapped to the uv value &#91;0 0&#93;,
and the opposite corner to the uv value &#91;1 1&#93;.
<P>
The texture map is the image to be mapped onto the
geometry field.
One requirement of the image (imposed by the hardware) is that the
number of pixels in each dimension must be a power of 2 greater
than or equal to 32.
The two dimensions do not have to be the same size.
The texture map should be attached to the geometry field as an
attribute, with the attribute name "texture," which
can be done with the Options module.

A texture-mapped image can be retrieved from the Display window using
ReadImageWindow and then written to a file using WriteImage.

<P>

<BR>
<TABLE BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Attribute Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">Value
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">texture
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="22%">a texture map
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="44%">specifies a texture map
</TD></TR></TABLE>

<P>
<P><STRONG>Components</STRONG>
<P>
The <TT><STRONG>object</STRONG></TT> input must have a "colors,"
"front colors," or "back colors" component.
<P><STRONG>Script Language Examples</STRONG>
<OL>
<P><LI>This example renders two views of the object and displays them in
two separate windows, as specified by the <TT><STRONG>where</STRONG></TT>
parameter.
<PRE>
electrondensity = Import("/usr/lpp/dx/samples/data/watermolecule");
isosurface = Isosurface(electrondensity, 0.3);
camera1 = AutoCamera(isosurface, "front", resolution=300);
camera2 = AutoCamera(isosurface, "top", resolution=300);
image1 = Render(isosurface, camera1);
image2 = Render(isosurface, camera2);
Display(image1,where="X, localhost:0, view from front");
Display(image2,where="X, localhost:0, view from top");
</PRE>
<P><LI>This example sets the rendering mode to "hardware" with the
approximation method of "dots."
<PRE>
electrondensity = Import("/usr/lpp/dx/samples/data/watermolecule");
isosurface = Isosurface(electrondensity, 0.3);
from = Direction(65, 5, 10);
camera = AutoCamera(isosurface, from);
isosurface=Options(isosurface, "rendering mode", "hardware",
                  "rendering approximation", "dots");
Display(isosurface,camera);
</PRE>
</OL>
<P><STRONG>Example Visual Programs</STRONG>
<PRE>
MovingCamera.net
PlotLine.net
PlotTwoLines.net
ReadImage.net

ScaleScreen.net

TextureMapOpenGL.net
UsingCompute.net
UsingMorph.net
</PRE>
<P><STRONG>See Also</STRONG>
<P>
&nbsp;<A HREF="refgu012.htm#HDRARRANGE">Arrange</A>,
&nbsp;<A HREF="refgu029.htm#HDRCOLLECT">Collect</A>,
&nbsp;<A HREF="refgu061.htm#HDRFILTER">Filter</A>,
&nbsp;<A HREF="refgu072.htm#HDRIMAGE">Image</A>,
&nbsp;<A HREF="refgu118.htm#HDRRENDER">Render</A>,

&nbsp;<A HREF="refgu113.htm#HDRREDUCE">Reduce</A>,
&nbsp;<A HREF="refgu114.htm#HDRREFINE">Refine</A>,
&nbsp;<A HREF="refgu130.htm#HDRSCALSCR">ScaleScreen</A>,
&nbsp;<A HREF="refgu097.htm#HDRNORMALS">Normals</A>,
&nbsp;<A HREF="refgu059.htm#HDRFACENOR">FaceNormals</A>,
&nbsp;<A HREF="refgu153.htm#HDRSUPWIND">SuperviseWindow</A>,
&nbsp;<A HREF="refgu152.htm#HDRSUPSTAT">SuperviseState</A>,
&nbsp;<A HREF="refgu111.htm#HDRREADIMW">ReadImageWindow</A>,
&nbsp;<A HREF="refgu098.htm#HDROPTIONS">Options</A>

<P><HR><B>&#91; <A HREF="#Top_Of_Page">Top of Page</A> &#124; <A
HREF="refgu047.htm">Previous Page</A> &#124; <A HREF="refgu049.htm">Next
Page</A> &#124; <A HREF="../refguide.htm#ToC">Table of Contents</A> &#124; <A
HREF="refgu009.htm#PToC4">Partial Table of Contents</A> &#124; <A
HREF="refgu175.htm#HDRINDEX_START">Index</A> &#93;</B> <br><b>&#91;<a
href="../allguide.htm">Data Explorer Documentation</a>&nbsp;&#124;&nbsp;<a
href="../qikguide.htm">QuickStart Guide</a>&nbsp;&#124;&nbsp;<a
href="../usrguide.htm">User&#39;s Guide</a>&nbsp;&#124;&nbsp;<a
href="../refguide.htm">User&#39;s Reference</a>&nbsp;&#124;&nbsp;<a
href="../proguide.htm">Programmer&#39;s Reference</a>&nbsp;&#124;&nbsp;<a
href="../insguide.htm">Installation and Configuration
Guide</a>&nbsp;&#93;</b><br><p><b>&#91;<a
href="http://www.almaden.ibm.com/dx/">Data Explorer Home
Page</a>&nbsp;&#124;&nbsp;<a
href="http://www.almaden.ibm.com/dx/DXMailForm.html">Contact Data
Explorer</a>&nbsp;&#124;&nbsp;<a
href="http://www.almaden.ibm.com/dx/docs/html/refguide.htm">Same document on
Data Explorer Home Page</a>&nbsp;&#93;</b><p><HR ALIGN=LEFT WIDTH=600><b>&#91;<A
HREF="http://www.ibm.com/">IBM Home Page</A>&nbsp;&#124;&nbsp;<A
HREF="http://www.ibm.com/Orders/">Order</A>&nbsp;&#124;&nbsp;<A
HREF="http://www.ibm.com/Search/">Search</A>&nbsp;&#124;&nbsp;<A
HREF="http://www.ibm.com/Assist/">Contact IBM</A>&nbsp;&#124;&nbsp;<A
HREF="http://www.ibm.com/Legal/">Legal</A>&nbsp;&#93;</b><hr><p>
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
